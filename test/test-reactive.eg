
require-macros:
   "../src/struct" ->
      struct
   earl-mocha ->
      describe, it, before, after, before-each, after-each
      xdescribe, xit
      assert, asserts
      expect-error

require:
   "../src/index" ->
      make-struct, read-proxy, Directory, ID
   "../src/reactive" ->
      Reactive, reactive-function, System
   ;; "../src/array" ->
   ;;    SBArray, A
   "./people" ->
      alice, bob, clara, donald, emily, francis, gerard, helen
      aid, bid, cid, did, eid, fid, gid, hid


count-calls{f} =
   rval{*args} =
      rval.count += 1
      f.apply{this, args}
   rval.count = 0
   rval


describe "utilities":

   it "count-calls":
      count-calls! f{x, y} = x + y
      assert f{10, 20} == 30
      assert f.count == 1
      assert f{7, 8} == 15
      assert f.count == 2


describe "Reactive functions":

   before-each:

      count-calls! reactive-function! @say-name{person} =
         ;; print person.name
         {greeting = 'Hello, my name is {person.name}!'}

      ;; count-calls! reactive-function! @say-names{people} =
      ;;    rval = SBArray{people each person -> 'Hello, my name is {person.name}!'}
      ;;    rval
      ;;    people each person -> 'Hello, my name is {person.name}!'

      count-calls! reactive-function! @say-parent-names{person} =
         {mother = @say-name{person.mother}
          father = @say-name{person.father}}


   it "called through System":
      sys = System{clara, @say-name}
      assert sys.get{} == {greeting = 'Hello, my name is clara!'}

   it "can be updated":

      sys = System{clara, @say-name}
      assert sys.get{} == {greeting = 'Hello, my name is clara!'}

      sys.transact with {clara} ->
         clara.name = "clairette"
      assert sys.get{} == {greeting = 'Hello, my name is clairette!'}

   it "is parsimonious":

      assert @say-name.orig.count == 0

      ;; Called to initialize
      sys = System{clara, @say-name}
      assert @say-name.orig.count == 1

      ;; Change is irrelevant because @say-name does not use age,
      ;; so @say-name should not be called again.
      sys.transact with {clara} ->
         clara.age = 21
      assert @say-name.orig.count == 1

      ;; Change is relevant, @say-name should be called
      sys.transact with {clara} ->
         clara.name = "clairette"
      assert @say-name.orig.count == 2

      ;; Irrelevant change again
      sys.transact with {clara} ->
         clara.mother = clara.father
      assert @say-name.orig.count == 2

      ;; Relevant change again
      sys.transact with {clara} ->
         clara.name = "bob"
      assert @say-name.orig.count == 3

      assert sys.get{} == {greeting = 'Hello, my name is bob!'}

   it "composes":
      sys = System{clara, @say-parent-names}

      assert sys.get{} == {
         mother = {greeting = 'Hello, my name is alice!'}
         father = {greeting = 'Hello, my name is bob!'}
      }

   it "compositions can be modified":

      sys = System{clara, @say-parent-names}

      sys.transact with {clara} ->
         clara.mother.name = .balice

      assert sys.get{} == {
         mother = {greeting = 'Hello, my name is balice!'}
         father = {greeting = 'Hello, my name is bob!'}
      }


   it "compositions can be modified and are parsimonious":

      assert @say-parent-names.orig.count == 0
      assert @say-name.orig.count == 0

      sys = System{clara, @say-parent-names}

      assert @say-parent-names.orig.count == 1
      assert @say-name.orig.count == 2

      sys.transact with {clara} ->
         clara.mother.name = .balice

      assert @say-parent-names.orig.count == 1
      assert @say-name.orig.count == 3

      sys.transact with {clara} ->
         clara.father.age = 88

      assert @say-parent-names.orig.count == 1
      assert @say-name.orig.count == 3

      sys.transact with {clara} ->
         clara.father.name = .gob
         clara.mother = clara.father

      assert @say-parent-names.orig.count == 2
      assert @say-name.orig.count == 4

      assert sys.get{} == {
         mother = {greeting = 'Hello, my name is gob!'}
         father = {greeting = 'Hello, my name is gob!'}
      }

   it "operates in-place":
      sys = System{clara, @say-parent-names}
      orig = sys.get{}
      assert orig == {
         mother = {greeting = 'Hello, my name is alice!'}
         father = {greeting = 'Hello, my name is bob!'}
      }
      sys.transact with {clara} ->
         {=> mother, => father} = clara
         {clara.mother, clara.father} = {father, mother}
      assert orig == {
         mother = {greeting = 'Hello, my name is bob!'}
         father = {greeting = 'Hello, my name is alice!'}
      }


   describe "miscellaneous tests":

      it "swap":
         sys = System{clara, @say-parent-names}
         sys.transact with {clara} ->
            {=> mother, => father} = clara
            {clara.mother, clara.father} = {father, mother}
         assert sys.get{} == {
            mother = {greeting = 'Hello, my name is bob!'}
            father = {greeting = 'Hello, my name is alice!'}
         }

      it "change all":
         sys = System{clara, @say-parent-names}
         sys.transact with {clara} ->
            {=> mother, => father} = clara
            mother.name = .yann
            father.name = .zoe
            {clara.mother, clara.father} = {father, mother}
         assert sys.get{} == {
            mother = {greeting = 'Hello, my name is zoe!'}
            father = {greeting = 'Hello, my name is yann!'}
         }

      it "deep change":
         sys = System{clara, @say-parent-names}
         sys.transact with {clara} ->
            clara.mother.name = .gertrude
         assert sys.get{} == {
            mother = {greeting = 'Hello, my name is gertrude!'}
            father = {greeting = 'Hello, my name is bob!'}
         }

      it "some test":

         sys = System{clara, @say-parent-names}

         sys.transact with {clara} ->
            clara.mother = emily
            clara.father = donald

         assert sys.get{} == {
            mother = {greeting = 'Hello, my name is emily!'}
            father = {greeting = 'Hello, my name is donald!'}
         }

         sys.transact with {clara} ->
            clara.mother.name = .esmeralda
            clara.father.name = .dumbledore

         assert sys.get{} == {
            mother = {greeting = 'Hello, my name is esmeralda!'}
            father = {greeting = 'Hello, my name is dumbledore!'}
         }





;;    describe "on SBArray":

;;       before-each:
;;          @people = A{alice, bob, clara}
;;          @sys = System{@people, @say-names}

;;       it "basic":
;;          assert @sys.value == {
;;             'Hello, my name is alice!'
;;             'Hello, my name is bob!'
;;             'Hello, my name is clara!'
;;          }
;;          @sys.transact with {people} ->
;;             people.get{0}.name = .albert
;;          assert @sys.value == {
;;             'Hello, my name is albert!'
;;             'Hello, my name is bob!'
;;             'Hello, my name is clara!'
;;          }
;;          @sys.transact with {people} ->
;;             people.set{0, donald}
;;          assert @sys.value == {
;;             'Hello, my name is donald!'
;;             'Hello, my name is bob!'
;;             'Hello, my name is clara!'
;;          }

;;       it "modify with each":
;;          @sys.transact with {people} ->
;;             people each person -> person.name += "o"
;;          assert @sys.value == {
;;             'Hello, my name is aliceo!'
;;             'Hello, my name is bobo!'
;;             'Hello, my name is clarao!'
;;          }

;;       it "push value":
;;          @sys.transact with {people} ->
;;             people.push with fork{donald}
;;          assert @sys.value == {
;;             'Hello, my name is alice!'
;;             'Hello, my name is bob!'
;;             'Hello, my name is clara!'
;;             'Hello, my name is donald!'
;;          }

