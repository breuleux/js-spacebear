
require-macros:
   earl-mocha ->
      describe, it, before, after, before-each, after-each
      xdescribe, xit
      assert, asserts
      expect-error

require:
   "../src/fork" ->
      fork
   "../src/array" ->
      SBArray
   "../src/index" ->
      patch
      ID, FORKID


describe "SBArray":

   before-each:
      @a = SBArray{1, 2, 3}
      @b = SBArray{4, 5, 6}
      @c = SBArray{@a, @b}

   it "get":
      assert @a.get{0} == 1
      assert @a.get{1} == 2
      assert @a.get{2} == 3

   it "fork":
      c2 = fork{@c}
      assert @c !== c2
      assert @c[ID] == c2[ID]
      assert @c[FORKID] != c2[FORKID]
      assert c2.get{0} !== @a
      assert c2.get{1} !== @b
      c2.get{0}.push{4}
      assert [@a each x -> x] == {1, 2, 3}
      assert [c2.get{0} each x -> x] == {1, 2, 3, 4}
      assert [c2.get{1} each x -> x] == {4, 5, 6}


describe "SBArray proxy":

   before-each:
      @a = SBArray{1, 2, 3}
      @id = @a[ID]
      @tracks = {=}
      @patch = {=}
      @p = @a.proxy{@tracks, @patch}
      @spldata{} = @patch[@id]["@splice"]

   it "get":
      assert @p.get{0} == 1
      assert @p.get{2} == 3
      assert @tracks == {
         @id => {0 => true, 2 => true}
      }

   it "iter":
      @p each x -> x
      assert @tracks == {
         @id => {"@iter" => {0, 3}}
      }

   it "for-each":
      @p.for-each{x -> x}
      assert @tracks == {
         @id => {"@iter" => {0, 3}}
      }

   it "map":
      assert @p.map{x -> x} == {1, 2, 3}
      assert @tracks == {
         @id => {"@iter" => {0, 3}}
      }

   it "slice":
      values = @p.slice{1, 2} each x -> x
      assert values == {2}
      assert @tracks == {
         @id => {"@iter" => {1, 2}}
      }
      @p.slice{0} each x -> x
      assert @tracks == {
         @id => {"@iter" => {0, 3}}
      }

   it "set":
      @p.set{0, 11}
      @p.set{1, 22}
      @p.set{2, 33}
      assert @spldata{} == {
         {1, {11}}
         {1, {22}}
         {1, {33}}
         undefined
      }

   it "push":
      @p.push{11}
      @p.push{22, 33}
      assert @spldata{} == {
         undefined
         undefined
         undefined
         {0, {11, 22, 33}}
      }

   it "pop":
      @p.pop{2}
      assert @spldata{} == {
         undefined
         {2, {}}
         true
         undefined
      }

   it "shift":
      @p.shift{2}
      assert @spldata{} == {
         {2, {}}
         true
         undefined
         undefined
      }

   it "unshift":
      @p.unshift{11}
      @p.unshift{22, 33}
      assert @spldata{} == {
         {0, {22, 33, 11}}
         undefined
         undefined
         undefined
      }

   it "replace":
      @p.replace with {11, 22, 33}
      assert @spldata{} == {
         {3, {11, 22, 33}}
         true
         true
         undefined
      }

   it "complex case":
      @p.unshift{11}
      @p.push{22}
      @p.splice{1, 2}
      assert @spldata{} == {
         {0, {11}}
         {2, {}}
         true
         {0, {22}}
      }


describe "SBArray patching":
   describe "shallow":
      before-each:
         @a = SBArray{1, 2, 3}
         @id = @a[ID]
         @tracks = {=}
         @patch = {=}
         @p = @a.proxy{@tracks, @patch}

      it "patch (1)":
         @p.splice{1, 0, 11, 22, 33, 44}
         @p.splice{2, 0, 88, 99}
         patch{@a, @patch}
         assert @a._a == {1, 11, 22, 33, 44, 2, 88, 99, 3}

      it "patch (2)":
         @p.unshift{11}
         @p.push{22}
         @p.splice{1, 2}
         patch{@a, @patch}
         assert @a._a == {11, 1, 22}

   describe "deep":
      before-each:
         @a = SBArray{1, 2, 3}
         @b = SBArray{4, 5, 6}
         @c = SBArray{@a, @b}
         @tracks = {=}
         @patch = {=}
         @p = @c.proxy{@tracks, @patch}

      it "patch (1)":
         @p.get{0}.push{44}
         @p.get{1}.unshift{33}
         patch{@c, @patch}
         assert [@c.get{0} each x -> x] == {1, 2, 3, 44}
         assert [@c.get{1} each x -> x] == {33, 4, 5, 6}



