
require-macros:
   "../src/struct" ->
      struct
   earl-mocha ->
      describe, it, before, after, before-each, after-each
      xdescribe, xit
      assert, asserts
      expect-error

require:
   "../src/index" ->
      identify
      make-struct, read-proxy, write-proxy
      directory, Directory
      changed-relevantly, intersect
      ID, FORKID, DIRECTORY
   "./people" ->
      alice, bob, clara, donald, emily, francis, gerard, helen
      aid, bid, cid, did, eid, fid, gid, hid


is-clone{a, b} =
   a !== b and a == b


describe "directory":

   before-each:
      @dir = Directory{}
      @dir2 = Directory{duplicate = true, clobber-patch = true}

   describe "option: duplicate":

      describe "= false":
         it "acquires the same object only once":
            a = {ID => 1, x = 1, y = 2}
            @dir.acquire{a}
            assert @dir.get-all{1} == {a}
            b = @dir.acquire{a}
            assert a === b
            assert @dir.get-all{1} == {a}

         it "multiple copies of the 'same' object are only acquired once":
            a = {ID => 1, x = 1, y = 2}
            @dir.acquire{a}
            assert @dir.get-all{1} == {a}
            b = {ID => 1, x = 1, y = 2}
            @dir.acquire{b}
            assert @dir.get-all{1} == {a}

         it "reference counting":
            a = {ID => 1, x = 1}
            b = {ID => 2, x = 2}
            c = {ID => 3, x = 3}
            d = {ID => 4, x = a, y = b}
            e = {ID => 5, x = b, y = c}
            f = {ID => 6, d = d, e = e}

            @dir.acquire{f}
            ;; {d, e} each entry ->
            ;;    @dir.acquire{entry}
            {a, b, c, d, e} each entry ->
               assert @dir.get-all{entry[ID]} == {entry}

            @dir.exit{d}
            {a, d} each entry ->
               assert @dir.get-all{entry[ID]} == {}
            {b, c, e} each entry ->
               assert @dir.get-all{entry[ID]} == {entry}

            @dir.exit{e}
            {a, b, c, d, e} each entry ->
               assert @dir.get-all{entry[ID]} == {}


      describe "= true":
         it "acquires the same object more than once":
            a = {ID => 1, x = 1, y = 2}
            @dir2.acquire{a}
            assert @dir2.get-all{1} == {a}
            b = @dir2.acquire{a}
            assert a !== b
            assert @dir2.get-all{1} == {a, b}

         it "tracks multiple copies of the 'same' object":
            a = {ID => 1, x = 1, y = 2}
            @dir2.acquire{a}
            assert @dir2.get-all{1} == {a}

            b = {ID => 1, x = 1, y = 2}
            @dir2.acquire{b}

            assert @dir2.get-all{1} == {a, b}

         it "reference counting":
            a = {ID => 1, x = 1}
            b = {ID => 2, x = 2}
            c = {ID => 3, x = 3}
            d = {ID => 4, x = a, y = b}
            e = {ID => 5, x = b, y = c}
            f = {ID => 6, d = d, e = e}

            @dir2.acquire{f}
            {{a, 1}, {b, 2}, {c, 1}, {d, 1}, {e, 1}} each {entry, nclones} ->
               assert @dir2.get-all{entry[ID]} == [1..nclones each x -> entry]

            d2 = @dir2.get{f[ID]}.d
            @dir2.exit{d2}
            {{a, 0}, {b, 1}, {c, 1}, {d, 0}, {e, 1}} each {entry, nclones} ->
               assert @dir2.get-all{entry[ID]} == [1..nclones each x -> entry]

            e2 = @dir2.get{f[ID]}.e
            @dir2.exit{e2}
            {{a, 0}, {b, 0}, {c, 0}, {d, 0}, {e, 0}} each {entry, nclones} ->
               assert @dir2.get-all{entry[ID]} == [1..nclones each x -> entry]


   describe "acquire":

      it "assimilates unaffiliated objects":
         obj = {a = 1, b = 2}
         obj2 = @dir.acquire{obj}
         assert obj === obj2
         assert obj[DIRECTORY] === @dir

      it "forks assimilated objects":
         obj = {a = 1, b = 2}
         obj2 = @dir.acquire{obj}
         dir2 = Directory{}
         obj3 = dir2.acquire{obj}
         assert obj === obj2
         assert obj !== obj3
         assert obj[DIRECTORY] === @dir
         assert obj3[DIRECTORY] === dir2

   describe "fork":
      before-each:
         @clara = @dir.fork{clara}
         @donald = @dir.fork{donald}

      it "preserves information":
         assert @clara.name == .clara
         assert @clara.age == 20
         assert @clara.mother.name == .alice
         assert @clara.father.name == .bob

      it "is deep":
         assert @clara !== clara
         assert @clara.mother !== clara.mother
         assert @clara.father !== clara.father

      it "maps same ID to same object if duplicate = false (default)":
         assert @donald.mother === @donald.father

      it "creates copies for same ID if duplicate = true":
         @dir = Directory{duplicate = true}
         @clara = @dir.fork{clara}
         @donald = @dir.fork{donald}
         assert @donald.mother !== @donald.father

   describe "clobber":

      it "overwrites data":
         @clara = @dir2.acquire{clara}
         {=> mother, => father} = @clara
         assert father.name === .bob
         assert @dir2.get-all{aid} == {alice}
         assert @dir2.get-all{bid} == {bob}
         assert @dir2.get-all{eid} == {}

         @emily = @dir2.clobber{mother, emily}
         assert @emily === mother
         assert mother.name === .emily
         assert @dir2.get-all{aid} == {}
         assert @dir2.get-all{bid} == {bob}
         assert @dir2.get-all{eid} == {emily}

      it "properly clobber data with same ids":
         @donald = @dir2.acquire{donald}
         {=> mother, => father} = @donald
         assert mother !== father
         assert mother.name === .alice
         assert father.name === .alice
         assert @dir2.get-all{aid} == {alice, alice}
         assert @dir2.get-all{eid} == {}

         @emily = @dir2.clobber{mother, emily}
         assert @emily === mother
         assert mother.name === .emily
         assert father.name === .alice
         assert @dir2.get-all{aid} == {alice}
         assert @dir2.get-all{eid} == {emily}


   describe "replace":

      it "do not clobber when duplicate = false":
         @clara = @dir.acquire{clara}
         {=> mother, => father} = @clara
         assert mother.name === .alice
         assert @dir.get-all{aid} == {alice}
         assert @dir.get-all{bid} == {bob}
         assert @dir.get-all{eid} == {}

         @emily = @dir.replace{mother, emily}
         assert @emily !== mother
         assert mother.name === .alice
         assert @dir.get-all{aid} == {}
         assert @dir.get-all{bid} == {bob}
         assert @dir.get-all{eid} == {emily}

      it "clobber when duplicate = true":
         @clara = @dir2.acquire{clara}
         {=> mother, => father} = @clara
         assert mother.name === .alice
         assert @dir2.get-all{aid} == {alice}
         assert @dir2.get-all{bid} == {bob}
         assert @dir2.get-all{eid} == {}

         @emily = @dir2.replace{mother, emily}
         assert @emily === mother
         assert mother.name === .emily
         assert @dir2.get-all{aid} == {}
         assert @dir2.get-all{bid} == {bob}
         assert @dir2.get-all{eid} == {emily}

   describe "patch, duplicate = false":

      before-each:
         @data = {=}
         @clara = @dir.acquire{clara}
         @clarap = write-proxy{@clara, @data}
         @donald = @dir.acquire{donald}
         @donaldp = write-proxy{@donald, @data}

      it "updates mutable structures (shallow)":
         @clarap.name = .clairette
         @clarap.age = 21
         assert @clara.name == .clara
         assert @clara.age == 20
         @dir.patch{@data}
         assert @clara.name == .clairette
         assert @clara.age == 21

      it "updates mutable structures (deep)":
         @clarap.name = .clairette
         @clarap.mother.age = 21
         assert @clara.name == .clara
         assert @clara.mother.age == 51
         @dir.patch{@data}
         assert @clara.name == .clairette
         assert @clara.mother.age == 21

      it "update with objects":
         @clarap.name = .clairette
         @clarap.mother = emily
         assert @clara.mother.name == .alice
         @dir.patch{@data}
         assert @clara.mother.name == .emily
         assert emily !== @clara.mother ;; it's a copy

      it "multiple patching":
         {=> mother, => father} = @donald

         ;; First round
         @donaldp.mother = emily
         @dir.patch{@data}

         ;; Second round
         @data = {=}
         @donaldp = write-proxy{@donald, @data}
         @donaldp.mother.age = 900
         @dir.patch{@data}

         assert @donald.mother == {name = .emily, age = 900}
         assert @donald.father == alice

      it "multiple patching (2)":
         {=> mother, => father} = @clara

         ;; First round
         @clarap.mother.age = 900
         @dir.patch{@data}

         ;; Second round
         @data = {=}
         @clarap = write-proxy{@clara, @data}
         @clarap.father = alice
         @dir.patch{@data}

         assert @clara.mother == {name = .alice, age = 900}
         assert @clara.father == {name = .alice, age = 900}


   describe "patch, duplicate = true":

      before-each:
         @data = {=}
         @clara = @dir2.acquire{clara}
         @clarap = write-proxy{@clara, @data}
         @donald = @dir2.acquire{donald}
         @donaldp = write-proxy{@donald, @data}

      it "updates all instances of an object":
         {=> mother, => father} = @donald
         assert mother == father  ;; same object contents
         assert mother !== father ;; but not same object reference

         @donaldp.mother.age = 21
         assert mother.age == 51
         assert father.age == 51
         @dir2.patch{@data}
         ;; donald's mother is also his father
         assert mother.age == 21
         assert father.age == 21

      it "adding an instance while modifying it":
         {=> mother, => father} = @clara
         @clarap.mother = @clarap.father
         @clarap.father.age = 66
         @dir2.patch{@data}
         assert @clara.mother == @clara.father
         assert @clara.mother !== @clara.father

      it "multiple patching":
         {=> mother, => father} = @donald

         ;; First round
         @donaldp.mother = emily
         @dir2.patch{@data}

         ;; Second round
         @data = {=}
         @donaldp = write-proxy{@donald, @data}
         @donaldp.mother.age = 900
         @dir2.patch{@data}

         assert @donald.mother == {name = .emily, age = 900}
         assert @donald.father == alice

      it "multiple patching (2)":
         {=> mother, => father} = @clara

         ;; First round
         @clarap.mother.age = 900
         @dir2.patch{@data}

         ;; Second round
         @data = {=}
         @clarap = write-proxy{@clara, @data}
         @clarap.father = alice
         @dir2.patch{@data}

         assert @clara.mother == {name = .alice, age = 900}
         assert @clara.father == {name = .alice, age = 900}


   describe "array":

      describe "patch":

         before-each:
            @patch = {=}
            @arr = @dir.acquire with {1, 2, 3}
            @p = write-proxy{@arr, @patch}
            @id = @arr[ID]

         it "set/push":
            @p.set{0, 11}
            @p.push{44}
            @dir.patch{@patch}
            assert @arr == {11, 2, 3, 44}

         it "unshift":
            @p.unshift{999}
            @dir.patch{@patch}
            assert @arr == {999, 1, 2, 3}


      describe "clobber":

         before-each:

            @clobber{old-arr, new-arr, test-preserve = true} =
               arr = @dir2.acquire{old-arr}
               arr-clone = arr each x -> x
               assert is-clone{arr, old-arr}
               arr2 = @dir2.clobber{arr, new-arr}
               assert arr === arr2
               assert is-clone{arr2, new-arr}
               if test-preserve:
                  @preserve-same-id{arr-clone, arr2}
               {arr-clone, arr2}

            @preserve-same-id{arr1, arr2} =
               id1 = {=}
               arr1 each
                  x and {^ID => Number? id} -> id1[id] = x
                  else -> continue
               arr2 each
                  x and {^ID => Number? id} when id1[id] ->
                     assert id1[id] === x

         it "scalar":
            @clobber{{1, 2, 3, 4}, {1, 2, 3, 4, 5}}

         it "push":
            @clobber{{alice, bob, clara}, {alice, bob, clara, donald}}

         it "reorder":
            @clobber{{alice, bob, clara}, {donald, clara, alice, bob}}

         it "with clones before":
            {{a1, a2, b1}, {a3, b2}} =
               @clobber{{alice, alice, bob}, {alice, bob}, false}
            assert a1 === a3 or a2 === a3
            assert b1 === b2

         it "with clones after":
            {{a1, b1}, {a2, a3, b2}} =
               @clobber{{alice, bob}, {alice, alice, bob}, false}
            assert a1 === a2 or a1 === a3
            assert a2 !== a3
            assert b1 === b2

         it "misc 1":
            @clobber{{alice, bob, clara, donald, emily}
                     {bob, emily, clara, francis, gerard}}

         it "misc 2":
            @clobber{{alice, bob, clara, clara, donald, emily}
                     {bob, emily, clara, francis, clara, gerard}, false}



