
require-macros:
   "../src/struct" ->
      struct
   earl-mocha ->
      describe, it, before, after, before-each, after-each
      xdescribe, xit
      assert, asserts
      expect-error

require:
   "../src/index" ->
      identify
      make-struct, read-proxy, write-proxy
      fork, directory, patch, changed-relevantly, intersect
      clobber
      ID


struct Person:
   name, age, mother, father
   ;; String? name
   ;; Number? age
   ;; Person? mother or null? mother = null
   ;; Person? father or null? father = null
   say-name{} =
      'My name is {@name}!'
   get-older{n = 1} =
      @age += n

alice = Person{name = .alice, age = 51}
bob = Person{name = .bob, age = 56}
clara = Person{name = .clara, age = 20, mother = alice, father = bob}
donald = Person{name = .donald, age = 10, mother = alice, father = alice}

aid = alice[ID]
bid = bob[ID]
cid = clara[ID]
did = donald[ID]

describe "structs":

   it "store information":
      assert alice.name == .alice
      assert clara.age == 20
      assert clara.mother.name == .alice
      assert clara.father.name == .bob

   it "are immutable":
      expect-error Error:
         alice.name = .balice
      expect-error Error:
         clara.mother.name = .balice

   it "can have methods":
      assert alice.say-name{} == "My name is alice!"
      assert bob.say-name{} == "My name is bob!"

   it "cannot be mutated through methods":
      expect-error Error:
         alice.get-older{}


describe "fork":

   before-each:
      @clara = fork{clara}
      @donald = fork{donald}

   it "preserves information":
      assert @clara.name == .clara
      assert @clara.age == 20
      assert @clara.mother.name == .alice
      assert @clara.father.name == .bob

   it "is deep":
      assert @clara !== clara
      assert @clara.mother !== clara.mother
      assert @clara.father !== clara.father

   it "preserves identity":
      assert @donald.mother === @donald.father


describe "read-proxy":

   before-each:
      @data = {=}
      @clara = read-proxy{clara, @data}

   it "tracks reads (shallow)":
      {@clara.name, @clara.age}
      assert @data == {cid => {name = true, age = true}}

   it "tracks reads (through methods)":
      @clara.say-name{}
      assert @data == {cid => {name = true}}

   it "tracks reads (deep)":
      {@clara.name, @clara.mother.age}
      assert @data == {
         cid => {name = true, mother = true}
         aid => {age = true}
      }

   ;; it "can store a predetermined key":
   ;;    @data = {=}
   ;;    @clara = clara.read-proxy{@data, 1234}
   ;;    {@clara.name, @clara.mother.age}
   ;;    assert @data == {
   ;;       cid => {name = 1234, mother = 1234}
   ;;       aid => {age = 1234}
   ;;    }


describe "write-proxy":

   before-each:
      @data = {=}
      @clara = write-proxy{clara, @data}

   it "tracks writes (shallow)":
      @clara.name = .clairette
      @clara.age = 21
      assert @data == {
         cid => {
            name = #update{.clairette}
            age = #update{21}
         }
      }

   it "tracks writes (through methods)":
      @clara.get-older{10}
      assert @data == {
         cid => {
            age = #update{30}
         }
      }

   it "tracks writes (deep)":
      @clara.name = .clairette
      @clara.mother.age = 21
      assert @data == {
         cid => {
            name = #update{.clairette}
         }
         aid => {
            age = #update{21}
         }
      }

   it "disallows reading what was just written":
      @clara.name
      @clara.name = .clairette
      expect-error true:
         @clara.name


describe "patch":

   before-each:
      @data = {=}
      @clara = fork{clara}
      @clarap = write-proxy{@clara, @data}

   it "updates mutable structures (shallow)":
      @clarap.name = .clairette
      @clarap.age = 21
      assert @clara.name == .clara
      assert @clara.age == 20
      patch{@clara, @data}
      assert @clara.name == .clairette
      assert @clara.age == 21

   it "updates mutable structures (deep)":
      @clarap.name = .clairette
      @clarap.mother.age = 21
      assert @clara.name == .clara
      assert @clara.mother.age == 51
      patch{@clara, @data}
      assert @clara.name == .clairette
      assert @clara.mother.age == 21

   it "updates all instances of an object":
      @data = {=}
      @donald = fork{donald}
      @donaldp = write-proxy{@donald, @data}
      @donaldp.mother.age = 21
      patch{@donald, @data}
      ;; donald's mother is also his father
      assert @donald.mother.age == 21
      assert @donald.father.age == 21

   it "works multiple times":

      @donald = fork{donald}
      @dir = directory{@donald}

      @data = {=}
      @donaldp = write-proxy{@donald, @data}
      @donaldp.mother.age = 21
      @donaldp.father = fork{bob}
      patch{@donald, @data, @dir}

      @data = {=}
      @donaldp = write-proxy{@donald, @data}
      @donaldp.father.age = 99
      patch{@donald, @data, @dir}

      assert @donald.mother.age == 21
      assert @donald.father.age == 99


describe "changed-relevantly and intersect":

   before-each:
      @tracks = {=}
      @patch = {=}
      @clara = fork{clara}
      @dir = directory{@clara}
      @clarar = read-proxy{@clara, @tracks}
      @claraw = write-proxy{@clara, @patch}

   it "tracks relevant changes":
      @clarar.name
      @claraw.name = .clairette
      assert changed-relevantly{@clara, @tracks[cid], @patch[cid]}
      assert intersect{@tracks, @patch, @dir}

   it "does not track irrelevant changes":
      @clarar.name
      @claraw.age = 20
      assert not changed-relevantly{@clara, @tracks[cid], @patch[cid]}
      assert not intersect{@tracks, @patch, @dir}

   it "operates on individual objects":
      @clarar.name
      @clarar.mother.age
      @claraw.mother.age = 20
      assert not changed-relevantly{@clara, @tracks[cid], @patch[cid]}
      assert changed-relevantly{@clara.mother, @tracks[aid], @patch[aid]}
      assert intersect{@tracks, @patch, @dir}


describe "clobber":

   before-each:
      identify! @x = {a = 1, b = 2}
      @xid = @x[ID]
      @clobber{y} =
         the-patch = {=}
         if not clobber{@x, y, the-patch}:
            throw E.noclobber{}
         the-patch[@xid]

   it "works":
      assert @clobber{{a = 3, b = 4}} == {
         a = #update{3}
         b = #update{4}
      }

   it "is parsimonious":
      assert @clobber{{a = 1, b = 4}} == {
         b = #update{4}
      }

   it "deletes missing properties":
      assert @clobber{{b = 2}} == {
         a = #delete{}
      }

   it "adds new properties":
      assert @clobber{{a = 1, b = 2, c = 3}} == {
         c = #update{3}
      }

   it "tying it all together":
      assert @clobber{{b = 3, c = 4}} == {
         a = #delete{}
         b = #update{3}
         c = #update{4}
      }

   it "delete all properties":
      assert @clobber{{=}} == {
         a = #delete{}
         b = #delete{}
      }

   it "can only clobber if same prototype":
      expect-error E.noclobber:
         @clobber{"baklava"}
      expect-error E.noclobber:
         @clobber{{}}
      expect-error E.noclobber:
         @clobber{Object.create{{=}}}

