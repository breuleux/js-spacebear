
require-macros:
   "../src/struct" ->
      struct
   earl-mocha ->
      describe, it, before, after, before-each, after-each
      xdescribe, xit
      assert, asserts
      expect-error

require:
   "../src/index" ->
      identify
      make-struct, read-proxy, write-proxy
      fork, directory, patch, changed-relevantly, intersect
      clobber
      ID


struct Person:
   name, age, mother, father
   ;; String? name
   ;; Number? age
   ;; Person? mother or null? mother = null
   ;; Person? father or null? father = null
   say-name{} =
      'My name is {@name}!'
   get-older{n = 1} =
      @age += n

alice = Person{name = .alice, age = 51}
bob = Person{name = .bob, age = 56}
clara = Person{name = .clara, age = 20, mother = alice, father = bob}
donald = Person{name = .donald, age = 10, mother = alice, father = alice}

aid = alice[ID]
bid = bob[ID]
cid = clara[ID]
did = donald[ID]

describe "structs":

   it "store information":
      assert alice.name == .alice
      assert clara.age == 20
      assert clara.mother.name == .alice
      assert clara.father.name == .bob

   it "are immutable":
      expect-error Error:
         alice.name = .balice
      expect-error Error:
         clara.mother.name = .balice

   it "can have methods":
      assert alice.say-name{} == "My name is alice!"
      assert bob.say-name{} == "My name is bob!"

   it "cannot be mutated through methods":
      expect-error Error:
         alice.get-older{}


describe "fork":

   before-each:
      @clara = fork{clara}
      @donald = fork{donald}

   it "preserves information":
      assert @clara.name == .clara
      assert @clara.age == 20
      assert @clara.mother.name == .alice
      assert @clara.father.name == .bob

   it "is deep":
      assert @clara !== clara
      assert @clara.mother !== clara.mother
      assert @clara.father !== clara.father

   it "preserves identity":
      assert @donald.mother === @donald.father


describe "read-proxy":

   before-each:
      @data = {=}
      @clara = read-proxy{clara, @data}

   it "tracks reads (shallow)":
      {@clara.name, @clara.age}
      assert @data == {cid => {name = true, age = true}}

   it "tracks reads (through methods)":
      @clara.say-name{}
      assert @data == {cid => {name = true}}

   it "tracks reads (deep)":
      {@clara.name, @clara.mother.age}
      assert @data == {
         cid => {name = true, mother = true}
         aid => {age = true}
      }

   ;; it "can store a predetermined key":
   ;;    @data = {=}
   ;;    @clara = clara.read-proxy{@data, 1234}
   ;;    {@clara.name, @clara.mother.age}
   ;;    assert @data == {
   ;;       cid => {name = 1234, mother = 1234}
   ;;       aid => {age = 1234}
   ;;    }


describe "write-proxy":

   before-each:
      @data = {=}
      @clara = write-proxy{clara, @data}

   it "tracks writes (shallow)":
      @clara.name = .clairette
      @clara.age = 21
      assert @data == {
         cid => {
            name = #update{.clairette}
            age = #update{21}
         }
      }

   it "tracks writes (through methods)":
      @clara.get-older{10}
      assert @data == {
         cid => {
            age = #update{30}
         }
      }

   it "tracks writes (deep)":
      @clara.name = .clairette
      @clara.mother.age = 21
      assert @data == {
         cid => {
            name = #update{.clairette}
         }
         aid => {
            age = #update{21}
         }
      }

   it "disallows reading what was just written":
      @clara.name
      @clara.name = .clairette
      expect-error true:
         @clara.name


describe "patch":

   before-each:
      @data = {=}
      @clara = fork{clara}
      @clarap = write-proxy{@clara, @data}

   it "updates mutable structures (shallow)":
      @clarap.name = .clairette
      @clarap.age = 21
      assert @clara.name == .clara
      assert @clara.age == 20
      patch{@clara, @data}
      assert @clara.name == .clairette
      assert @clara.age == 21

   it "updates mutable structures (deep)":
      @clarap.name = .clairette
      @clarap.mother.age = 21
      assert @clara.name == .clara
      assert @clara.mother.age == 51
      patch{@clara, @data}
      assert @clara.name == .clairette
      assert @clara.mother.age == 21

   it "updates all instances of an object":
      @data = {=}
      @donald = fork{donald}
      @donaldp = write-proxy{@donald, @data}
      @donaldp.mother.age = 21
      patch{@donald, @data}
      ;; donald's mother is also his father
      assert @donald.mother.age == 21
      assert @donald.father.age == 21

   it "works multiple times":

      @donald = fork{donald}
      @dir = directory{@donald}

      @data = {=}
      @donaldp = write-proxy{@donald, @data}
      @donaldp.mother.age = 21
      @donaldp.father = fork{bob}
      patch{@donald, @data, @dir}

      @data = {=}
      @donaldp = write-proxy{@donald, @data}
      @donaldp.father.age = 99
      patch{@donald, @data, @dir}

      assert @donald.mother.age == 21
      assert @donald.father.age == 99


describe "changed-relevantly and intersect":

   before-each:
      @tracks = {=}
      @patch = {=}
      @clara = fork{clara}
      @dir = directory{@clara}
      @clarar = read-proxy{@clara, @tracks}
      @claraw = write-proxy{@clara, @patch}

   it "tracks relevant changes":
      @clarar.name
      @claraw.name = .clairette
      assert changed-relevantly{@clara, @tracks[cid], @patch[cid]}
      assert intersect{@tracks, @patch, @dir}

   it "does not track irrelevant changes":
      @clarar.name
      @claraw.age = 20
      assert not changed-relevantly{@clara, @tracks[cid], @patch[cid]}
      assert not intersect{@tracks, @patch, @dir}

   it "operates on individual objects":
      @clarar.name
      @clarar.mother.age
      @claraw.mother.age = 20
      assert not changed-relevantly{@clara, @tracks[cid], @patch[cid]}
      assert changed-relevantly{@clara.mother, @tracks[aid], @patch[aid]}
      assert intersect{@tracks, @patch, @dir}


describe "clobber":

   before-each:
      identify! @x = {a = 1, b = 2}
      @xid = @x[ID]
      @clobber{y, expect-clobber = true} =
         rval = clobber{@x, y}
         assert rval == y
         if expect-clobber:
            assert rval === @x
            assert rval !== y
         else:
            assert rval !== @x
            assert rval === y
         rval

   it "works":
      @clobber{{a = 3, b = 4}}

   it "deletes missing properties":
      @clobber{{b = 2}}

   it "deletes all properties":
      @clobber{{=}}

   it "adds new properties":
      @clobber{{a = 3, b = 4, c = 5}}

   it "transfers ID":
      y = identify{{a = 3, b = 4, c = 5}}
      r = @clobber{y}
      assert r[ID] === y[ID]
      assert r[ID] !== @xid

   it "recursive":
      x = identify{{x = identify{{a = 1, b = 2}}, y = identify{{c = 3, d = 4}}}}
      y = identify{{x = identify{{a = 6, m = 7}}, y = identify{{n = 9}}}}
      r = clobber{x, y}
      assert x == y

   it "can only clobber if same prototype":
      y = Object.create{{=}}
      @clobber{y, false}

   it "wrap":
      test-wrap{x} = 'success {x.join{" "}}'
      x = {a = 1, b = 2}
      y = {1, 2, 3}
      r = clobber{x, y, test-wrap}
      assert r == 'success 1 2 3'

   it "wrap deep":
      test-wrap{x} = 'success {x.join{" "}}'
      x = {a = {x = 1, y = 2}}
      y = {a = {1, 2, 3}}
      r = clobber{x, y, test-wrap}
      assert r == {a = 'success 1 2 3'}
