
provide:
   make-struct, struct
   proxy, fork, patch

var _id = 0


next-id{} =
   _id += 1
   _id


maybe-freeze{obj, mutable} =
   if not mutable and Object.freeze:
      Object.freeze{obj}
   else:
      obj


proxy{obj, listener} =
   if not obj or not obj["::id"]:
      return obj
   if obj["::source"]:
      return proxy{obj["::source"], listener}
   return obj.proxy{listener}

fork{match obj, mutable = false} =
   null? or undefined? or String? or Number? or Boolean? ->
      obj
   else ->
      obj.fork{mutable}

patch{match obj, p} =
   null? or undefined? or String? or Number? or Boolean? ->
      obj
   else ->
      obj.patch{p}


proto-zero = Object.create{null} &: {

   proxy{listener} =
      obj = this
      cons = obj.constructor
      prox = Object.create{null}
      prox["::source"] = obj
      cons.field-names each name ->
         Object.define-property{prox, name} with {
            .get{} =
               listener.read{obj, name}
               proxy{obj[name], listener}
            .set{new-value} =
               listener.write{obj, name, new-value}
         }
      cons.method-names each name ->
         prox[name] = obj[name]
      prox

   fork{mutable = false} =
      obj = this
      cons = obj.constructor
      rval = object.create{cons.proto}
      cons.field-names each field ->
         rval[field] = fork{obj[field], mutable}
      rval["::id"] = obj["::id"]
      rval["::mutable"] = mutable
      maybe-freeze{rval, mutable}

   patch{p} =
      obj = this
      if not obj["::mutable"]:
         throw E.spacebear.patch with
            'Cannot patch immutable object. Make a mutable fork first.'
      if obj["::version"] === p.version:
         return obj
      obj["::version"] = p.version

      cons = obj.constructor
      var changes = false
      match p[obj["::id"]]:
         undefined? -> pass
         xs ->
            xs each
               #update{field, _, value} ->
                  changes = true
                  obj[field] = obj.validate-field{field, value}

      if changes:
         obj.validate{}

      cons.field-names each field ->
         patch{obj[field], p}

      obj

}

proto-array = Object.create{null} &: {

   fork{mutable = false} =
      pass

   patch{p} =
      pass

}

proto-map = Object.create{null} &: {

   fork{mutable = false} =
      pass

   patch{p} =
      pass

}



make-struct{name, fields, methods} =
   cid = Symbol{name}

   make{values, mutable = false} =
      rval = Object.create{proto}
      items{fields} each {name, settings} ->
         v = if{Object.has-property.call{values, name}, values[name], settings.default}
         rval[name] = rval.validate-field{name, v}

      Object.define-property{rval, "::id"} with {
         value = next-id{}
         enumerable = false
      }

      Object.define-property{rval, "constructor"} with {
         value = make
         enumerable = false
      }

      rval.validate{}
      if not mutable and Object.freeze:
         Object.freeze{rval}
      else:
         rval

   make.field-names = keys{fields}
   make.method-names = keys{methods}
   make.struct-name = name
   make.to-string{} = '{name}\{{this.field-names.join{", "}}\}'

   proto = Object.create{proto-zero}
   items{methods} each {name, method} ->
      proto[name] = method

   proto.validate-field{name, value} =
      settings = fields[name]
      if settings.validate:
         try:
            settings.validate{value}
         catch err:
            throw E.struct{'''Error setting '{name}': {err.message}''', err}
      else:
         value

   proto.validate or= {} -> this

   make


macro{make-struct} struct{`{^name, ^body}`} =
   #symbol{sname} or #value{sname} = name
   #multi! #multi{*stmts} = body

   ms = @deps["make-struct"]

   fields = #data{}
   methods = `methods`
   results = #splice{
      `methods = {=}`
   }
   stmts each match stmt ->
      `^lhs = ^rhs` or lhs and rhs is null ->
         pc = @PatternCompiler{lhs, @, opt} where opt =
            @pattern_handlers.build_object & {
               assign{#symbol{@camelCase! v} or #value{v}, value} =
                  #do{#assign{`[^methods][^=v]`, value}}
               declare{vars} = {}
               wrap_target{match} =
                  `^args -> ^body` ->
                     {env => other_env} = body
                     it = #symbol{"@"} & {env = other_env}
                     it2 = #symbol{"self"} & {env = other_env}
                     `_lambda{
                        ^args
                        splice: [let ^it = this, let ^it2 = this]
                        ^body
                        ^=null
                        ^=false
                     }`
                  other ->
                     other
               success{x} =
                  #multi{}
            }
         pc.compile{}

         match pc:
            {arguments => {}, vars => match} ->
               {v} and match is rhs ->
                  do: tr = `validate{x} = [^lhs = x, ^v]`
                  null? ->
                     fields.push with `^v = {^tr}`
                  else ->
                     fields.push with `^v = {^tr, default = ^rhs}`
               else ->
                  throw E.syntax.struct with
                     '''Pattern '{@gettext{lhs}}' should define exactly one variable.'''
                     node = lhs
            {=> arguments} when rhs == null ->
               throw E.syntax.struct with
                  '''Missing method body for: '{@gettext{lhs}}' '''
                  node = lhs
            {=> arguments} ->
               results.push with pc.extract_from_rhs{rhs}

   results.push with `^name = [^ms]{^=sname, ^fields, methods}`
   results
