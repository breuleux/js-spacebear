
require:
   "./util" ->
      tuck, identify, next-id, ID, FORKID, VERSION, SOURCE

provide:
   make-struct, struct
   read-proxy, write-proxy
   fork, patch
   changed-relevantly


maybe-freeze{obj, mutable} =
   if not mutable and Object.freeze:
      Object.freeze{obj}
   else:
      obj



read-proxy{obj, storage, key = true} =
   if not obj or not obj[ID]:
      return obj
   if obj[SOURCE]:
      return read-proxy{obj[SOURCE], storage, key}
   return obj.read-proxy{storage, key}

write-proxy{obj, storage} =
   if not obj or not obj[ID]:
      return obj
   if obj[SOURCE]:
      return write-proxy{obj[SOURCE], storage}
   return obj.write-proxy{storage}

deprox{x} =
   if x and x[SOURCE]:
      x[SOURCE]
   else:
      x

fork{match obj, mutable = false} =
   null? or undefined? or String? or Number? or Boolean? ->
      obj
   else ->
      obj.fork{mutable}

patch{match obj, p} =
   null? or undefined? or String? or Number? or Boolean? ->
      obj
   else ->
      obj.patch{p}

changed-relevantly{tracks, patch} =
   items{tracks} each {id, reads} ->
      obj = reads[SOURCE]
      if obj.changed-relevantly{reads, patch[id]}:
         return true
   false



proto-read-proxy = Object.create{null} &: {
   reprox{tracks, key = true} =
      read-proxy{this, tracks, key}
}

proto-write-proxy = Object.create{null} &: {
   reprox{patch} =
      write-proxy{this, patch}
}


proto-zero = Object.create{null} &: {

   generic-proxy{target, proto, field-wrapper} =
      obj = this
      id = obj[ID]
      target[id] or= Object.create{null}
      obj-data = target[id]
      cons = obj.constructor
      prox = Object.create{proto-read-proxy}
      tuck{prox, SOURCE, obj}
      tuck{obj-data, SOURCE, obj}
      cons.field-names each name ->
         field-wrapper{prox, name, obj-data}
      cons.method-names each name ->
         tuck{prox, name, obj[name]}
      prox

   read-proxy{tracks, key = true} =
      obj = this
      this.generic-proxy{tracks, proto-read-proxy} with
         {prox, name, obj-data} ->
            Object.define-property{prox, name} with {
               .get{} =
                  obj-data[name] = key
                  read-proxy{obj[name], tracks, key}
               enumerable = true
            }

   write-proxy{patch} =
      obj = this
      this.generic-proxy{patch, proto-write-proxy} with
         {prox, name, obj-data} ->
            Object.define-property{prox, name} with {
               .get{} =
                  if obj-data[name]:
                     throw E.invalid_access with
                        '''Cannot access property '{name}' after setting it.'''
                  write-proxy{obj[name], patch}
               .set{new-value} =
                  obj-data[name] = #update{deprox{new-value}}
            }

   fork{mutable = false} =
      obj = this
      cons = obj.constructor
      rval = Object.create{cons.proto}
      cons.field-names each field ->
         rval[field] = fork{obj[field], mutable}
      tuck{rval, ID, obj[ID]}
      tuck{rval, FORKID, next-id{}}
      tuck{rval, VERSION, 1}
      maybe-freeze{rval, mutable}

   patch{p} =
      obj = this
      if Object.is-frozen{obj}:
         throw E.spacebear.patch with
            'Cannot patch immutable object. Make a mutable fork first.'
      if obj[VERSION] === p[VERSION]:
         return obj
      tuck{obj, VERSION, p[VERSION]}

      cons = obj.constructor
      match p[obj[ID]]:
         undefined? -> pass
         items! [each {field, match}] ->
            #update{value} ->
               obj[field] = value

      cons.field-names each field ->
         patch{obj[field], p}

      obj

   changed-relevantly{tracks, patch} =
      items{patch or {=}} each
         {name, _} when tracks[name] ->
            return true
      return false

}



;; proto-array = Object.create{null} &: {

;;    .get{i} =
;;       this._a[i]

;;    ;; .set{i, value} =
;;    ;;    this._a[i] = this.validate-element{value}

;;    ;; splice{i, j, *elements} =
;;    ;;    values = elements each value -> this.validate-element{value}
;;    ;;    this._a.splice{i, j}

;;    proxy{listener} =
;;       obj = this
;;       prox[SOURCE] = obj
;;       prox.get{i} =
;;          listener.read{obj, i}
;;          proxy{obj[i], listener}
;;       prox.set{i, value} =
;;          listener.write{obj, i, value}
;;       prox.splice{i, j, *elements} =
;;          if j != elements.length:
;;             listener.write{obj, .length, obj.length - j + elements.length}
;;          listener.splice{i, j, elements}

;;       Object.define-property{prox, .length} with {
;;          .get{} =
;;             listener.read{obj, .length}
;;             obj.length
;;       }


;;       obj = this
;;       cons = obj.constructor
;;       prox = Object.create{null}
;;       cons.field-names each name ->
;;          Object.define-property{prox, name} with {
;;             .get{} =
;;                listener.read{obj, name}
;;                proxy{obj[name], listener}
;;             .set{new-value} =
;;                listener.write{obj, name, new-value}
;;          }
;;       cons.method-names each name ->
;;          prox[name] = obj[name]
;;       prox

;;    fork{mutable = false} =
;;       pass

;;    patch{p} =
;;       pass

;; }


;; make-array{elements, mutable = false} =
;;    rval = Object.create{proto-array}
;;    rval._a = maybe-freeze{clone{elements}}
;;    maybe-freeze{rval}




;; proto-map = Object.create{null} &: {

;;    fork{mutable = false} =
;;       pass

;;    patch{p} =
;;       pass

;; }



make-struct{name, fields, methods} =
   cid = Symbol{name}

   make{values, mutable = false} =
      rval = Object.create{proto}
      items{fields} each {name, settings} ->
         v = if{Object.has-property.call{values, name}, values[name], settings.default}
         rval[name] = v

      identify{rval}
      tuck{rval, FORKID, rval[ID]}
      tuck{rval, VERSION, 1}

      if not mutable and Object.freeze:
         Object.freeze{rval}
      else:
         rval

   make.field-names = keys{fields}
   make.method-names = keys{methods}
   make.struct-name = name
   make.to-string{} = '{name}\{{this.field-names.join{", "}}\}'

   proto = Object.create{proto-zero}
   items{methods} each {name, method} ->
      proto[name] = method

   ;; proto.validate-field{name, value} =
   ;;    settings = fields[name]
   ;;    if settings.validate:
   ;;       try:
   ;;          settings.validate{value}
   ;;       catch err:
   ;;          throw E.struct{'''Error setting '{name}': {err.message}''', err}
   ;;    else:
   ;;       value

   Object.define-property{proto, VERSION} with {
      value = 1
      writable = true
      enumerable = false
   }

   ;; proto.validate or= {} -> this

   Object.define-property{proto, "constructor"} with {
      value = make
      enumerable = false
   }

   make.proto = proto

   make["::check"]{match} =
      {constructor => === make} -> true
      else -> false

   make


macro{make-struct} struct{`{^name, ^body}`} =
   #symbol{sname} or #value{sname} = name
   #multi! #multi{*stmts} = body

   ms = @deps["make-struct"]

   fields = #data{}
   methods = `methods`
   results = #splice{
      `methods = {=}`
   }
   stmts each match stmt ->
      `^lhs = ^rhs` or lhs and rhs is null ->
         pc = @PatternCompiler{lhs, @, opt} where opt =
            @pattern_handlers.build_object & {
               assign{#symbol{@camelCase! v} or #value{v}, value} =
                  #do{#assign{`[^methods][^=v]`, value}}
               declare{vars} = {}
               wrap_target{match} =
                  `^args -> ^body` ->
                     {env => other_env} = body
                     it = #symbol{"@"} & {env = other_env}
                     it2 = #symbol{"self"} & {env = other_env}
                     `_lambda{
                        ^args
                        splice: [let ^it = this, let ^it2 = this]
                        ^body
                        ^=null
                        ^=false
                     }`
                  other ->
                     other
               success{x} =
                  #multi{}
            }
         pc.compile{}

         match pc:
            {arguments => {}, vars => match} ->
               {v} and match is rhs ->
                  do: tr = `validate{x} = [^lhs = x, ^v]`
                  null? ->
                     fields.push with `^v = {^tr}`
                  else ->
                     fields.push with `^v = {^tr, default = ^rhs}`
               else ->
                  throw E.syntax.struct with
                     '''Pattern '{@gettext{lhs}}' should define exactly one variable.'''
                     node = lhs
            {=> arguments} when rhs == null ->
               throw E.syntax.struct with
                  '''Missing method body for: '{@gettext{lhs}}' '''
                  node = lhs
            {=> arguments} ->
               results.push with pc.extract_from_rhs{rhs}

   results.push with `^name = [^ms]{^=sname, ^fields, methods}`
   results
