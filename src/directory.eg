
require:
   .object-fill -> object-clobber-helper
   .array-fill -> array-clobber-helper
   .misc-fill
   .util ->
      identify, fork-identify, tuck
      next-id, ID, FORKID, VERSION, DIRECTORY, CACHE
      methods
      longest-run
   .proxy ->
      deprox
   .iter ->
      iterate-properties

provide:
   Directory
   object-clobber-helper
   array-clobber-helper


class Directory:

   constructor{@options = {=}} =
      ;; Tie @duplicate to @clobber-patch by default, since they should
      ;; usually have the same value.
      {clobber-patch => @clobber-patch = false
       duplicate => @duplicate = @clobber-patch} = @options
      @dir = {=}
      @version = 1

   get-all{id} =
      match @dir[id]:
         undefined? -> {}
         {_, v} -> {v}
         objs -> items{objs} each {k, {_, v}} -> v

   get{id} =
      @get-all{id}[0]

   get-canon{v} =
      v and v[ID] and @get{v[ID]} or v

   enter{deprox! match value, add-children = true} =
      null? or undefined? or Number? or String? or Symbol? or Boolean? ->
         value
      do:
         identify! value
         fork-identify! value
      when not @duplicate ->
         match @dir[value[ID]]:
            undefined? ->
               tuck{value, DIRECTORY, @}
               @dir[value[ID]] = {1, value}
               if add-children:
                  iterate-properties{value} each
                     {k, v2, replace, ignore-children = false} ->
                        @enter{v2, not ignore-children}
               value
            {count, value} ->
               @dir[value[ID]] = {count + 1, value}
               value

      else ->
         sub = [@dir[value[ID]] or= {=}]
         fid = value[FORKID]
         match sub[fid]:
            undefined? ->
               tuck{value, DIRECTORY, @}
               sub[fid] = {1, value}
               if add-children:
                  iterate-properties{value} each
                     {k, v2, replace, ignore-children = false} ->
                        @enter{v2, not ignore-children}
               value
            {count, value} ->
               sub[fid] = {count + 1, value}
               value

   exit{match v, remove-children = true} =
      null? or undefined? or Number? or String? or Symbol? or Boolean? ->
         @
      deprox! v ->
         {d, String! k} =
            if @duplicate:
               sub = [@dir[v[ID]] or= {=}]
               {sub, v[FORKID]}
            else:
               {@dir, v[ID]}
         match d[k]:
            undefined? ->
               pass
            {match count, v} ->
               > 1 ->
                  d[k] = {count - 1, v}
               else ->
                  delete d[k]
                  delete v[DIRECTORY]
                  if remove-children:
                     iterate-properties{v} each
                        {k, v2, replace, ignore-children = false} ->
                           @exit{v2, not ignore-children}

   acquire-copy{deprox! v} =
      if v and not v[DIRECTORY]:
         ;; v can't belong to more than one directory, so we
         ;; acquire it with a throwaway Directory
         Directory{}.enter{v, true}
      @acquire{v}

   acquire{deprox! match v, add-children = true} =
      null? or undefined? or Number? or String? or Symbol? or Boolean? ->
         v
      identify! [{^DIRECTORY => d} or d is undefined] and match is d ->
         === [@] ->
            if{@duplicate, @fork{@get-canon{v}}, [@enter{v, false}; v]}
         undefined? when @duplicate ->
            @fork{@get-canon{v}}
         undefined? ->
            @enter{v, false}
            if add-children:
               iterate-properties{v} each
                  {k, deprox! v2, replace, ignore-children = false} ->
                     match @acquire{v2, not ignore-children}:
                        !== v2 ->
                           throw E.acquire with
                              'Child of {v}, {v2}, belongs to other directory.'
                        else ->
                           pass
            v
         else ->
            @fork{@get-canon{v}}

   acquire-get{v} =
      match @get{v[ID] or -1}:
         undefined? -> @acquire{v}
         x -> x

   fork{match value} =
      null? or undefined? ->
         value
      do:
         identify! value
      when not @duplicate and @get{value[ID]} ->
         @enter{@get{value[ID]}, false}
      else ->
         deprox{value}[methods.fork]{@}

   clobber{match value, new-value} =
      null? or undefined? ->
         new-value
      do:
         identify! value
         identify! new-value
      when value[ID] and value[ID] === new-value[ID] ->
         value
      else ->
         deprox{value}[methods.clobber]{new-value, @}

   replace{old-value, new-value} =
      if @clobber-patch:
         @clobber{old-value, @get-canon{new-value}}
      else:
         v = @acquire{new-value}
         @exit{old-value}
         v

   patch{p} =
      ;; TODO: investigate what happens when a patch introduces an
      ;; item with, say, ID == x, which needs to be patched, but the
      ;; patch for ID == x was applied before. This should be ok if
      ;; the item is already in the directory, otherwise it may fail.
      @version += 1
      p.list{} each {id, obj-patch} ->
         @get-all{id} each obj ->
            patch-shallow{obj, p, @}

   [^methods.fork]{dir} =
      throw E.fork{"Cannot fork directories."}
   [^methods.proxy]{tracks, patch, prevent-dirty-reads} =
      throw E.proxy{"Cannot proxy directories."}
   [^methods.patch]{p, dir} =
      throw E.patch{"Cannot patch directories."}
   [^methods.clobber]{new, dir} =
      throw E.clobber{"Cannot clobber directories."}
   [^methods.iterate-properties]{} =
      throw E.iterate{"Cannot iterate directories."}


;;;;;;;;;;;;;;;;;;;
;; PATCH HELPERS ;;
;;;;;;;;;;;;;;;;;;;

patch-shallow{deprox! match value, p, dir} =
   null? or undefined? -> ;; or Number? or String? or Symbol? or Boolean? ->
      pass
   else ->
      deprox{value}[methods.patch]{p, dir}

