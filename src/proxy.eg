
require:
   "./util" ->
      tuck, identify, next-id
      ID, FORKID, PROTOID
      VERSION, SOURCE, DIRECTORY
      methods, fields

provide:
   proxy, deprox, reprox
   object-proxy, array-proxy
   read-proxy, write-proxy


proxy{match value, tracks, patch, prevent-dirty-reads = true} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      value
   {^methods.proxy => Function?} ->
      deprox{value}[methods.proxy]{tracks, patch, prevent-dirty-reads}
   Array? ->
      array-proxy{deprox{value}, tracks, patch, prevent-dirty-reads}
   else ->
      object-proxy{deprox{value}, tracks, patch, prevent-dirty-reads}

deprox{x} =
   if x and x[SOURCE]:
      x[SOURCE]
   else:
      x

reprox{match value, tracks, patch} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      value
   {^SOURCE => true? obj} ->
      proxy{obj, tracks or obj[fields.tracks], patch or obj[fields.patch]}
   else ->
      proxy{value, tracks, patch}


read-proxy{value, tracks} =
   proxy{value, tracks, null}

write-proxy{value, patch} =
   proxy{value, null, patch}


setup-proxy{self, obj, tracks, patch, prevent-dirty-reads} =

   identify{obj}

   self[fields.obj] = obj
   self[fields.tracks] = tracks
   self[fields.patch] = patch
   self[fields.prevent-dirty-reads] = prevent-dirty-reads

   if tracks: tracks[DIRECTORY] or= obj[DIRECTORY]
   if patch:  patch[DIRECTORY]  or= obj[DIRECTORY]

   id = obj[ID]
   self[fields.obj-tracks] = tracks and id and [tracks[id] or= {=}]
   self[fields.obj-patch] = patch and id and [patch[id] or= {=}]
   if not self[fields.obj-patch]:
      self[fields.prevent-dirty-reads] = false

   tuck{self, SOURCE, obj}
   tuck{self, ID, obj[ID]}
   tuck{self, VERSION, obj[VERSION]}



basic-object-proxy{obj, tracks, patch
                   prevent-dirty-reads = true} =

   self = this
   setup-proxy{self, obj, tracks, patch, prevent-dirty-reads}
   Object.prevent-extensions{self}

basic-get{name} =
   self = this
   if self[fields.prevent-dirty-reads] and self[fields.obj-patch][name]:
      throw E.invalid_access with
         '''Cannot access property '{name}' after setting it.'''
   if self[fields.obj-tracks]: self[fields.obj-tracks][name] = true
   proxy{self[fields.obj][name]
         self[fields.tracks]
         self[fields.patch]
         self[fields.prevent-dirty-reads]}

basic-set{name, new-value} =
   self = this
   if self[fields.obj-patch]:
      self[fields.obj-patch][name] = #update{deprox{new-value}}


proxy-proto-cache = {=}

proxy-proto-for{obj} =
   orig-proto = Object.get-prototype-of{obj}
   pid = match orig-proto:
      null? or undefined? -> null
      when Object.has-own-property.call{orig-proto, PROTOID} ->
         orig-proto[PROTOID]
      else -> tuck{orig-proto, PROTOID, next-id{}}

   the-keys = keys{obj}.sort{}
   key = '{pid}\x01{the-keys.join{"\x00"}}'
   match proxy-proto-cache[key]:
      undefined? ->
         proto = Object.create{orig-proto}
         the-keys each name ->
            Object.define-property{proto, name} with {
               get{} = this._get{name}
               set{value} = this._set{name, value}
               enumerable = true
            }
         proto._get = basic-get
         proto._set = basic-set
         expr-value proxy-proto-cache[key] = proto
         proto
      proto ->
         proto

object-proxy{obj, tracks, patch, var prevent-dirty-reads = true} =
   p = proxy-proto-for{obj}
   basic-object-proxy.call{Object.create{p}, obj, tracks, patch, prevent-dirty-reads}



class array-proxy:

   constructor{obj and @_a
               tracks and @_tracks
               patch and @_patch
               prevent-dirty-reads = true} =

      self = [@]
      setup-proxy{@, obj, tracks, patch, prevent-dirty-reads}
      @_obj-tracks = self[fields.obj-tracks]
      @_obj-patch = self[fields.obj-patch]
      @_prevent-dirty-reads = self[fields.prevent-dirty-reads]

   _update-iter{match, i, j, stick-to-end = false} =
      undefined? ->
         {i, j, stick-to-end}
      {i2, j2} ->
         {Math.min{i, i2}, Math.max{j, j2}, stick-to-end}
      else ->
         {i, j, stick-to-end}

   ;; GETTERS

   get{i} =
      if @_prevent-dirty-reads and @_obj-patch[i]:
         throw E.invalid_access with
            '''Cannot access index '{i}' after setting it.'''
      if @_obj-tracks: @_obj-tracks[i] = true
      proxy{@_a[i], @_tracks, @_patch, @_prevent-dirty-reads}
      ;; @_proxies[i]

   slice{i = 0, var j = null} =
      stick = if{j === null, [j = @_a.length; true], false}
      if @_obj-tracks:
         @_obj-tracks["@iter"] = @_update-iter{@_obj-tracks["@iter"], i, j, stick}
      @_a.slice{i, j} each* x ->
         proxy{x, @_tracks, @_patch, @_prevent-dirty-reads}
      ;; @_proxies.slice{i, j} each* x -> x

   [^Symbol.iterator]{} =
      proxies = @_a each x -> proxy{x, @_tracks, @_patch, @_prevent-dirty-reads}
      if @_obj-tracks: @_obj-tracks["@iter"] = {0, @_a.length, true}
      proxies[Symbol.iterator]{}
      ;; @_proxies[Symbol.iterator]{}

   for-each{fn} =
      [@] each x -> fn{x}
      undefined

   map{fn} =
      [@] each x -> fn{x}

   join{sep} =
      [[@] each x -> x].join{sep}

   to-string{} =
      '\{{@join{", "}}\}'

   ;; SETTERS

   set{i, new-value} =
      @_splice{i, 1, {new-value}, false}

   pop{n = 1} =
      @_splice{@_a.length - n, n, {}, false}
   push{*values} =
      @_splice{@_a.length, 0, values, .append}

   shift{n = 1} =
      @_splice{0, n, {}, false}
   unshift{*values} =
      @_splice{0, 0, values, .prepend}

   .splice{i, n, *values} =
      @_splice{i, n, values, false}

   replace{new-array} =
      @_splice{0, @_a.length, new-array, false}

   ._splice{i, n, values, pos = false} =
      emsg = 'Inconsistent splicing (this may happen if you modify'
         \ + ' the array more than once at the same place)'
      d = [@_obj-patch["@splice"] or= Array{@_a.length + 1}]
      match d[i]:
         === true ->
            throw E.splice{emsg}
         undefined? ->
            d[i] = {n, values}
         {n2, previous-values} when n == 0 or n2 == 0 ->
            d[i] = {Math.max{n, n2}, new-values} where new-values =
               match pos:
                  .prepend -> values ++ previous-values
                  .append -> previous-values ++ values
                  else -> throw E.splice{emsg}
         else ->
            throw E.splice{emsg}
      1..[n - 1] each j ->
         match d[i + j]:
            undefined? ->
               d[i + j] = true
            else ->
               throw E.splice{emsg}

Object.define-property{array-proxy.prototype, .length} with {
   .get{} =
      if this._prevent-dirty-reads and this._obj-patch[.length]:
         throw E.invalid_access with
            '''Array length has changed.'''
      if this._obj-tracks: this._obj-tracks[.length] = true
      proxy{this._a.length, this._tracks, this._patch, this._prevent-dirty-reads}
}

