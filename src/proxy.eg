
require:
   "./util" ->
      tuck, identify, next-id
      ID, FORKID, PROTOID
      VERSION, SOURCE, DIRECTORY
      methods, fields

provide:
   Patch, Tracks
   proxy, deprox, reprox
   object-proxy, array-proxy
   read-proxy, write-proxy



class Patch:
   constructor{@data = {=}} =
      pass
   _data{} = @data
   get{id} =
      @data[id] or= {=}
   get-for{obj} =
      if not obj: return null
      id = obj[ID]
      id and [@data[id] or= {=}]
   shift{new-data = {=}} =
      {expr-value, @data} = {@data, new-data}
   list{} =
      items{@data}


class Tracks:
   constructor{@data = {=}} =
      pass
   _data{} =
      @data
   get{id} =
      id and [@data[id] or= {=}]
   get-for{obj} =
      if not obj: return null
      id = obj[ID]
      id and [@data[id] or= {=}]
   list{} =
      items{@data}



proxy{match value, tracks, patch, prevent-dirty-reads = true} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      value
   {^methods.proxy => Function?} ->
      deprox{value}[methods.proxy]{tracks, patch, prevent-dirty-reads}
   Array? ->
      array-proxy{deprox{value}, tracks, patch, prevent-dirty-reads}
   else ->
      object-proxy{deprox{value}, tracks, patch, prevent-dirty-reads}

deprox{x} =
   if x and x[SOURCE]:
      x[SOURCE]
   else:
      x

reprox{match value, tracks, patch} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      value
   {^SOURCE => true? obj} ->
      proxy{obj, tracks or value[fields.tracks], patch or value[fields.patch]}
   else ->
      proxy{value, tracks, patch}


read-proxy{value, tracks} =
   proxy{value, tracks, null}

write-proxy{value, patch} =
   proxy{value, null, patch}


setup-proxy{self, obj, tracks, patch, prevent-dirty-reads} =

   identify{obj}

   self[fields.obj] = obj
   self[fields.tracks] = tracks
   self[fields.patch] = patch
   self[fields.prevent-dirty-reads] = prevent-dirty-reads

   if tracks: tracks[DIRECTORY] or= obj[DIRECTORY]
   if patch:  patch[DIRECTORY]  or= obj[DIRECTORY]

   id = obj[ID]

   ;; self[fields.obj-tracks] = tracks and id and [tracks[id] or= {=}]
   ;; self[fields.obj-patch] = patch and patch.get-for{obj}

   Object.define-property{self, fields.obj-tracks} with
      get{} = tracks and tracks.get-for{obj}
   ;; tracks and id and [tracks[id] or= {=}]
   Object.define-property{self, fields.obj-patch} with
      get{} = patch and patch.get-for{obj}

   if not self[fields.obj-patch]:
      self[fields.prevent-dirty-reads] = false

   tuck{self, SOURCE, obj}
   tuck{self, ID, obj[ID]}
   tuck{self, VERSION, obj[VERSION]}


basic-object-proxy{obj, tracks, patch
                   prevent-dirty-reads = true} =
   self = this
   setup-proxy{self, obj, tracks, patch, prevent-dirty-reads}
   Object.prevent-extensions{self}

basic-get{name} =
   self = this
   if self[fields.prevent-dirty-reads]
      \ and self[fields.obj-patch][name]:
      throw E.invalid_access with
         '''Cannot access property '{name}' after setting it.'''
   if self[fields.obj-tracks]: self[fields.obj-tracks][name] = true
   proxy{self[fields.obj][name]
         self[fields.tracks]
         self[fields.patch]
         self[fields.prevent-dirty-reads]}

basic-set{name, new-value} =
   self = this
   if self[fields.obj-patch]:
      self[fields.obj-patch][name] = #update{deprox{new-value}}


proxy-proto-cache = {=}

proxy-proto-for{obj} =
   orig-proto = Object.get-prototype-of{obj}
   pid = match orig-proto:
      null? or undefined? -> null
      when Object.has-own-property.call{orig-proto, PROTOID} ->
         orig-proto[PROTOID]
      else -> tuck{orig-proto, PROTOID, next-id{}}

   the-keys = keys{obj}.sort{}
   key = '{pid}\x01{the-keys.join{"\x00"}}'
   match proxy-proto-cache[key]:
      undefined? ->
         proto = Object.create{orig-proto}
         the-keys each match name ->
            R"^__"? ->
               Object.define-property{proto, name} with {
                  get{} = this[fields.obj][name]
                  enumerable = true
               }
            else ->
               Object.define-property{proto, name} with {
                  get{} = this._get{name}
                  set{value} = this._set{name, value}
                  enumerable = true
               }
         proto._get = basic-get
         proto._set = basic-set
         expr-value proxy-proto-cache[key] = proto
         proto
      proto ->
         proto

object-proxy{obj, tracks, patch, var prevent-dirty-reads = true} =
   p = proxy-proto-for{obj}
   basic-object-proxy.call{Object.create{p}, obj, tracks, patch, prevent-dirty-reads}



class array-proxy:

   constructor{obj, tracks, patch, prevent-dirty-reads = true} =
      setup-proxy{@, obj, tracks, patch, prevent-dirty-reads}

   _update-iter{match, i, j, stick-to-end = false} =
      undefined? ->
         {i, j, stick-to-end}
      {i2, j2} ->
         {Math.min{i, i2}, Math.max{j, j2}, stick-to-end}
      else ->
         {i, j, stick-to-end}

   ;; GETTERS

   get{i} =
      if self[fields.prevent-dirty-reads]
         \ and self[fields.obj-patch][i]:
         throw E.invalid_access with
            '''Cannot access index '{i}' after setting it.'''
      if self[fields.obj-tracks]: self[fields.obj-tracks][i] = true
      proxy{self[fields.obj][i]
            self[fields.tracks]
            self[fields.patch]
            self[fields.prevent-dirty-reads]}

   slice{i = 0, var j = null} =
      stick = if{j === null, [j = self[fields.obj].length; true], false}
      if self[fields.obj-tracks]:
         self[fields.obj-tracks]["@iter"] =
            @_update-iter{self[fields.obj-tracks]["@iter"], i, j, stick}
      self[fields.obj].slice{i, j} each* x ->
         proxy{x
               self[fields.tracks]
               self[fields.patch]
               self[fields.prevent-dirty-reads]}

   [^Symbol.iterator]{} =
      proxies = self[fields.obj] each x ->
         proxy{x
               self[fields.tracks]
               self[fields.patch]
               self[fields.prevent-dirty-reads]}
      if self[fields.obj-tracks]:
         self[fields.obj-tracks]["@iter"] =
            {0, self[fields.obj].length, true}
      proxies[Symbol.iterator]{}

   for-each{fn} =
      [@] each x -> fn{x}
      undefined

   index-of{deprox! elem} =
      @_update-iter{self[fields.obj-tracks]["@iter"], 0, @length, true}
      self[fields.obj].index-of{elem}

   map{fn} =
      [@] each x -> fn{x}

   join{sep} =
      [[@] each x -> x].join{sep}

   to-string{} =
      '\{{@join{", "}}\}'

   ;; SETTERS

   set{i, new-value} =
      @_splice{i, 1, {new-value}, false}

   remove{deprox! elem} =
      idx = self[fields.obj].index-of{elem}
      if idx !== -1:
         @splice{idx, 1}

   pop{n = 1} =
      @_splice{self[fields.obj].length - n, n, {}, false}
   push{*values} =
      @_splice{self[fields.obj].length, 0, values, .append}

   shift{n = 1} =
      @_splice{0, n, {}, false}
   unshift{*values} =
      @_splice{0, 0, values, .prepend}

   .splice{i, n, *values} =
      @_splice{i, n, values, false}

   replace{new-array} =
      @_splice{0, self[fields.obj].length, new-array, false}

   ;; remove{i, new-value} =
   ;;    @_splice{i, 1, {new-value}, false}

   ._splice{i, n, values, pos = false} =
      emsg = 'Inconsistent splicing (this may happen if you modify'
         \ + ' the array more than once at the same place)'
      d = [self[fields.obj-patch]["@splice"] or= Array{self[fields.obj].length + 1}]
      match d[i]:
         === true ->
            throw E.splice{emsg}
         undefined? ->
            d[i] = {n, values}
         {n2, previous-values} when n == 0 or n2 == 0 ->
            d[i] = {Math.max{n, n2}, new-values} where new-values =
               match pos:
                  .prepend -> values ++ previous-values
                  .append -> previous-values ++ values
                  else -> throw E.splice{emsg}
         else ->
            throw E.splice{emsg}
      1..[n - 1] each j ->
         match d[i + j]:
            undefined? ->
               d[i + j] = true
            else ->
               throw E.splice{emsg}

Object.define-property{array-proxy.prototype, .length} with {
   .get{} =
      if this[fields.prevent-dirty-reads]
         \ and this[fields.obj-patch][.length]:
         throw E.invalid_access with
            '''Array length has changed.'''
      if this[fields.obj-tracks]:
         this[fields.obj-tracks][.length] = true
      proxy{this[fields.obj].length
            this[fields.tracks]
            this[fields.patch]
            this[fields.prevent-dirty-reads]}
}

