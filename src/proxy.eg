
require:
   "./util" ->
      tuck, identify, next-id
      ID, FORKID, PROTOID
      VERSION, SOURCE, DIRECTORY

provide:
   deprox, proxy, object-proxy, read-proxy, write-proxy


deprox{x} =
   if x and x[SOURCE]:
      x[SOURCE]
   else:
      x


proxy{match value, tracks, patch, prevent-dirty-reads = true} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      value
   {proxy => Function?} ->
      deprox{value}.proxy{tracks, patch, prevent-dirty-reads}
   Array? ->
      array-proxy{deprox{value}, tracks, patch, prevent-dirty-reads}
   else ->
      object-proxy{deprox{value}, tracks, patch, prevent-dirty-reads}


read-proxy{value, tracks} =
   proxy{value, tracks, null}

write-proxy{value, patch} =
   proxy{value, null, patch}


basic-object-proxy{obj, tracks, patch
                   prevent-dirty-reads = true} =

   [@] = this
   @_obj = obj
   @_tracks = tracks
   @_patch = patch
   @_prevent-dirty-reads = prevent-dirty-reads

   identify{obj}

   if tracks: tracks[DIRECTORY] or= obj[DIRECTORY]
   if patch:  patch[DIRECTORY]  or= obj[DIRECTORY]

   id = obj[ID]
   @_obj-tracks = tracks and id and [tracks[id] or= {=}]
   @_obj-patch = patch and id and [patch[id] or= {=}]
   if not @_obj-patch:
      @_prevent-dirty-reads = false

   tuck{@, SOURCE, obj}
   tuck{@, ID, obj[ID]}
   tuck{@, VERSION, obj[VERSION]}

   Object.prevent-extensions{@}

basic-get{name} =
   [@] = this
   if @_prevent-dirty-reads and @_obj-patch[name]:
      throw E.invalid_access with
         '''Cannot access property '{name}' after setting it.'''
   if @_obj-tracks: @_obj-tracks[name] = true
   proxy{@_obj[name], @_tracks, @_patch, @_prevent-dirty-reads}

basic-set{name, new-value} =
   [@] = this
   if @_obj-patch:
      @_obj-patch[name] = #update{deprox{new-value}}


proxy-proto-cache = {=}

proxy-proto-for{obj} =
   orig-proto = Object.get-prototype-of{obj}
   pid = if{orig-proto, tuck{orig-proto, PROTOID, next-id{}}, null}
   the-keys = keys{obj}.sort{}
   key = '{pid}\x01{the-keys.join{"\x00"}}'
   match proxy-proto-cache[key]:
      undefined? ->
         proto = Object.create{orig-proto}
         the-keys each name ->
            Object.define-property{proto, name} with {
               get{} = this._get{name}
               set{value} = this._set{name, value}
               enumerable = true
            }
         proto._get = basic-get
         proto._set = basic-set
         expr-value proxy-proto-cache[key] = proto
      proto ->
         proto

object-proxy{obj, tracks, patch, var prevent-dirty-reads = true} =
   p = proxy-proto-for{obj}
   basic-object-proxy.call{Object.create{p}, obj, tracks, patch, prevent-dirty-reads}


class array-proxy:

   constructor{obj and @_a
               tracks and @_tracks
               patch and @_patch
               @_prevent-dirty-reads = true} =

      identify{obj}
      if tracks: tracks[DIRECTORY] or= obj[DIRECTORY]
      if patch:  patch[DIRECTORY]  or= obj[DIRECTORY]

      id = obj[ID]
      @_obj-tracks = tracks and id and [tracks[id] or= {=}]
      if @_obj-tracks:
         tuck{@_obj-tracks, SOURCE, obj}

      @_obj-patch = patch and id and [patch[id] or= {=}]
      if @_obj-patch:
         tuck{@_obj-patch, SOURCE, obj}
      else:
         @_prevent-dirty-reads = false

      tuck{@, SOURCE, obj}

      ;; @_proxies = @_a each x ->
      ;;    proxy{x, @_tracks, @_patch, @_prevent-dirty-reads}

   _update-iter{match, i, j, stick-to-end = false} =
      undefined? ->
         {i, j, stick-to-end}
      {i2, j2} ->
         {Math.min{i, i2}, Math.max{j, j2}, stick-to-end}
      else ->
         {i, j, stick-to-end}

   ;; GETTERS

   get{i} =
      if @_prevent-dirty-reads and @_obj-patch[i]:
         throw E.invalid_access with
            '''Cannot access index '{i}' after setting it.'''
      if @_obj-tracks: @_obj-tracks[i] = true
      proxy{@_a[i], @_tracks, @_patch, @_prevent-dirty-reads}
      ;; @_proxies[i]

   slice{i = 0, var j = null} =
      stick = if{j === null, [j = @_a.length; true], false}
      if @_obj-tracks:
         @_obj-tracks["@iter"] = @_update-iter{@_obj-tracks["@iter"], i, j, stick}
      @_a.slice{i, j} each* x ->
         proxy{x, @_tracks, @_patch, @_prevent-dirty-reads}
      ;; @_proxies.slice{i, j} each* x -> x

   [^Symbol.iterator]{} =
      proxies = @_a each x -> proxy{x, @_tracks, @_patch, @_prevent-dirty-reads}
      if @_obj-tracks: @_obj-tracks["@iter"] = {0, @_a.length, true}
      proxies[Symbol.iterator]{}
      ;; @_proxies[Symbol.iterator]{}

   for-each{fn} =
      [@] each x -> fn{x}
      undefined

   map{fn} =
      [@] each x -> fn{x}

   join{sep} =
      [[@] each x -> x].join{sep}

   to-string{} =
      '\{{@join{", "}}\}'

   ;; SETTERS

   set{i, new-value} =
      @_splice{i, 1, {new-value}, false}

   pop{n = 1} =
      @_splice{@_a.length - n, n, {}, false}
   push{*values} =
      @_splice{@_a.length, 0, values, .append}

   shift{n = 1} =
      @_splice{0, n, {}, false}
   unshift{*values} =
      @_splice{0, 0, values, .prepend}

   .splice{i, n, *values} =
      @_splice{i, n, values, false}

   replace{new-array} =
      @_splice{0, @_a.length, new-array, false}

   ._splice{i, n, values, pos = false} =
      emsg = 'Inconsistent splicing (this may happen if you modify'
         \ + ' the array more than once at the same place)'
      d = [@_obj-patch["@splice"] or= Array{@_a.length + 1}]
      match d[i]:
         === true ->
            throw E.splice{emsg}
         undefined? ->
            d[i] = {n, values}
         {n2, previous-values} when n == 0 or n2 == 0 ->
            d[i] = {Math.max{n, n2}, new-values} where new-values =
               match pos:
                  .prepend -> values ++ previous-values
                  .append -> previous-values ++ values
                  else -> throw E.splice{emsg}
         else ->
            throw E.splice{emsg}
      1..[n - 1] each j ->
         match d[i + j]:
            undefined? ->
               d[i + j] = true
            else ->
               throw E.splice{emsg}

Object.define-property{array-proxy.prototype, .length} with {
   .get{} =
      if this._prevent-dirty-reads and this._obj-patch[.length]:
         throw E.invalid_access with
            '''Array length has changed.'''
      if this._obj-tracks: this._obj-tracks[.length] = true
      proxy{this._a.length, this._tracks, this._patch, this._prevent-dirty-reads}
}

