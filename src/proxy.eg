
require:
   "./util" ->
      tuck, identify, next-id, ID, FORKID, VERSION, SOURCE, DIRECTORY

provide:
   deprox, proxy, object-proxy, read-proxy, write-proxy


deprox{x} =
   if x and x[SOURCE]:
      x[SOURCE]
   else:
      x


proxy{match value, tracks, patch, prevent-dirty-reads = true} =

   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      value

   {proxy => Function?} ->
      deprox{value}.proxy{tracks, patch, prevent-dirty-reads}

   Array? ->
      array-proxy{deprox{value}, tracks, patch, prevent-dirty-reads}
      ;; throw E.spacebear.proxy with
      ;;    'Cannot proxy arrays. Wrap with spacebear.Array.'

   else ->
      object-proxy{deprox{value}, tracks, patch, prevent-dirty-reads}
      ;; throw E.spacebear.proxy with
      ;;    '''Cannot proxy '{value}'. Try defining a .proxy method.'''



read-proxy{value, tracks} =
   proxy{value, tracks, null}

write-proxy{value, patch} =
   proxy{value, null, patch}



object-proxy{obj, tracks, patch, var prevent-dirty-reads = true} =
   frz = Object.is-frozen{obj}
   if not frz:
      identify{obj}

   if tracks: tracks[DIRECTORY] or= obj[DIRECTORY]
   if patch:  patch[DIRECTORY]  or= obj[DIRECTORY]

   id = obj[ID]
   obj-tracks = tracks and id and [tracks[id] or= {=}]
   ;; if obj-tracks:
   ;;    tuck{obj-tracks, SOURCE, obj}

   obj-patch = patch and id and [patch[id] or= {=}]
   ;; if obj-patch:
   ;;    tuck{obj-patch, SOURCE, obj}
   ;; else:
   if not obj-patch:
      prevent-dirty-reads = false

   getfn{name}{} =
      if prevent-dirty-reads and obj-patch[name]:
         throw E.invalid_access with
            '''Cannot access property '{name}' after setting it.'''
      if obj-tracks: obj-tracks[name] = true
      proxy{obj[name], tracks, patch, prevent-dirty-reads}

   setfn{name} =
      if obj-patch:
         {new-value} ->
            obj-patch[name] = #update{deprox{new-value}}

   prox = Object.create{Object.get-prototype-of{obj}}
   tuck{prox, SOURCE, obj}
   tuck{prox, ID, obj[ID]}
   tuck{prox, VERSION, obj[VERSION]}
   keys{obj} each name ->
      Object.define-property{prox, name} with {
         .get = getfn{name}
         .set = setfn{name}
         enumerable = true
      }
   Object.prevent-extensions{prox}
   prox


array-proxy{obj and a, tracks, patch, var prevent-dirty-reads = true} =

   identify{obj}

   id = obj[ID]
   obj-tracks = tracks and id and [tracks[id] or= {=}]
   if obj-tracks:
      tuck{obj-tracks, SOURCE, obj}

   obj-patch = patch and id and [patch[id] or= {=}]
   if obj-patch:
      tuck{obj-patch, SOURCE, obj}
   else:
      prevent-dirty-reads = false

   update-iter{match, i, j, stick-to-end = false} =
      undefined? ->
         {i, j, stick-to-end}
      {i2, j2} ->
         {Math.min{i, i2}, Math.max{j, j2}, stick-to-end}
      else ->
         {i, j, stick-to-end}

   prox = Object.create{Object.create{Array.prototype} &: [getters & setters]} where

      getters = {
         .get{i} =
            if prevent-dirty-reads and obj-patch[i]:
               throw E.invalid_access with
                  '''Cannot access index '{i}' after setting it.'''
            if obj-tracks: obj-tracks[i] = true
            proxy{a[i], tracks, patch, prevent-dirty-reads}
         slice{i = 0, var j = null} =
            stick = if{j === null, [j = a.length; true], false}
            if obj-tracks:
               obj-tracks["@iter"] = update-iter{obj-tracks["@iter"], i, j, stick}
            obj.slice{i, j} each* x ->
               proxy{x, tracks, patch, prevent-dirty-reads}
         ^Symbol.iterator = {} ->
            proxies = obj each x -> proxy{x, tracks, patch, prevent-dirty-reads}
            if obj-tracks: obj-tracks["@iter"] = {0, a.length, true}
            proxies[Symbol.iterator]{}
         for-each{fn} =
            this each x -> fn{x}
            undefined
         map{fn} =
            this each x -> fn{x}
         join{sep} =
            self = this
            [self each x -> x].join{sep}
         to-string{} =
            '\{{this.join{", "}}\}'
      }

      setters =
         if obj-patch: {
            .set{i, new-value} =
               this._splice{i, 1, {new-value}, false}

            pop{n = 1} =
               this._splice{a.length - n, n, {}, false}
            push{*values} =
               this._splice{a.length, 0, values, .append}

            shift{n = 1} =
               this._splice{0, n, {}, false}
            unshift{*values} =
               this._splice{0, 0, values, .prepend}

            .splice{i, n, *values} =
               this._splice{i, n, values, false}

            replace{new-array} =
               this._splice{0, a.length, new-array, false}

            ._splice{i, n, values, pos = false} =
               emsg = 'Inconsistent splicing (this may happen if you modify'
                  \ + ' the array more than once at the same place)'
               d = [obj-patch["@splice"] or= Array{a.length + 1}]
               match d[i]:
                  === true ->
                     throw E.splice{emsg}
                  undefined? ->
                     d[i] = {n, values}
                  {n2, previous-values} when n == 0 or n2 == 0 ->
                     d[i] = {Math.max{n, n2}, new-values} where new-values =
                        match pos:
                           .prepend -> values ++ previous-values
                           .append -> previous-values ++ values
                           else -> throw E.splice{emsg}
                  else ->
                     throw E.splice{emsg}
               1..[n - 1] each j ->
                  match d[i + j]:
                     undefined? ->
                        d[i + j] = true
                     else ->
                        throw E.splice{emsg}
         }

         else: {
            _splice{} =
               throw E.immutable{'''Cannot modify {obj}'''}
         }

   Object.define-property{prox, .length} with {
      .get{} =
         if prevent-dirty-reads and obj-patch[.length]:
            throw E.invalid_access with
               '''Array length has changed.'''
         if obj-tracks: obj-tracks[.length] = true
         proxy{obj[.length], tracks, patch, prevent-dirty-reads}
   }

   prox




