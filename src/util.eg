
provide:
   tuck
   ID, CLOBBERID, FORKID, PROTOID, VERSION, SOURCE, DIRECTORY, CACHE
   methods, fields
   next-id, identify, fork-identify
   longest-run

tuck{obj, name, value, writable = true} =
   Object.define-property{obj, name} with {
      value = value
      enumerable = false
      writable = writable
      configurable = true
   }

ID = Symbol{.id}
FORKID = Symbol{.forkid}
PROTOID = Symbol{.protoid}
VERSION = Symbol{.version}
SOURCE = Symbol{.source}
CLOBBERID = Symbol{.clobberid}
DIRECTORY = Symbol{.directory}
CACHE = Symbol{.cache}

methods = {
   proxy = Symbol{.proxy}
   iterate-properties = Symbol{.iterate-properties}
   fork = Symbol{.fork}
   patch = Symbol{.patch}
   clobber = Symbol{.clobber}
   changed-relevantly = Symbol{.changed-relevantly}
}

fields = {
   obj = Symbol{.obj}
   tracks = Symbol{.tracks}
   patch = Symbol{.patch}
   prevent-dirty-reads = Symbol{.prevent-dirty-reads}
   obj-tracks = Symbol{.obj-tracks}
   obj-patch = Symbol{.obj-patch}
   system = Symbol{.system}
}


var _id = 0

next-id{} =
   _id += 1
   _id

identify{match x} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      x
   when x[ID] ->
      x
   else ->
      tuck{x, ID, next-id{}}
      x

fork-identify{match x} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      x
   when x[FORKID] ->
      x
   else ->
      tuck{x, FORKID, next-id{}}
      x



longest-run{match indices, cmp = {x, y} -> x < y, minimum = -1} =
   {} -> {}
   {match x, *rest} ->
      do: baseline = longest-run{rest, cmp, minimum}
      null? or when not cmp{minimum, x} ->
         baseline
      else ->
         rval = longest-run{rest, cmp, x}
         if rval.length < baseline.length:
            baseline
         else:
            rval.unshift{x}
            rval



