
provide:
   tuck
   ID, CLOBBERID, FORKID, PROTOID, VERSION, SOURCE, DIRECTORY, CACHE
   methods, fields
   next-id, identify, fork-identify
   longest-run

tuck{obj, name, value, writable = true} =
   Object.define-property{obj, name} with {
      value = value
      enumerable = false
      writable = writable
      configurable = true
   }

ID = Symbol{.id}
FORKID = Symbol{.forkid}
PROTOID = Symbol{.protoid}
VERSION = Symbol{.version}
SOURCE = Symbol{.source}
CLOBBERID = Symbol{.clobberid}
DIRECTORY = Symbol{.directory}
CACHE = Symbol{.cache}

methods = {
   proxy = Symbol{.proxy}
   iterate-properties = Symbol{.iterate-properties}
   fork = Symbol{.fork}
   patch = Symbol{.patch}
   clobber = Symbol{.clobber}
   changed-relevantly = Symbol{.changed-relevantly}
}

fields = {
   obj = Symbol{.obj}
   tracks = Symbol{.tracks}
   patch = Symbol{.patch}
   prevent-dirty-reads = Symbol{.prevent-dirty-reads}
   obj-tracks = Symbol{.obj-tracks}
   obj-patch = Symbol{.obj-patch}
   system = Symbol{.system}
}


var _id = 0

next-id{} =
   _id += 1
   _id

identify{match x} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      x
   when x[ID] ->
      x
   else ->
      tuck{x, ID, next-id{}}
      x

fork-identify{match x} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      x
   when x[FORKID] ->
      x
   else ->
      tuck{x, FORKID, next-id{}}
      x



;; longest-run{match indices, cmp = {x, y} -> x < y, minimum = -1} =
;;    {} -> {}
;;    {match x, *rest} ->
;;       do: baseline = longest-run{rest, cmp, minimum}
;;       null? or when not cmp{minimum, x} ->
;;          baseline
;;       when baseline.length > 0 and cmp{x, baseline[0]} ->
;;          baseline.unshift{x}
;;          baseline
;;       else ->
;;          rval = longest-run{rest, cmp, x}
;;          if rval.length < baseline.length:
;;             baseline
;;          else:
;;             rval.unshift{x}
;;             rval

longest-run{indices, cmp = {x, y} -> x < y, minimum = -1} =
   cache = {=}
   helper{i, minimum} =
      key = '{i}/{minimum}'
      if cache[key]:
         return cache[key]
      r =
         if i == indices.length:
            {}
         else:
            x = indices[i]
            baseline = helper{i + 1, minimum}
            if x === null or not cmp{minimum, x}:
               baseline
            elif baseline.length > 0 and cmp{x, baseline[0]}:
               ;; baseline.unshift{x}
               ;; baseline
               {x} ++ baseline
            else:
               rval = helper{i + 1, x}
               if rval.length < baseline.length:
                  baseline
               else:
                  ;; rval.unshift{x}
                  ;; rval
                  {x} ++ rval
      cache[key] = r
      r
   helper{0, minimum}
