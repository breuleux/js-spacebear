
require:
   "./util" ->
      SOURCE, methods

provide:
   intersect, changed-relevantly


intersect{tracks, patch, dir} =
   patch.list{} each {id, writes} ->
      obj = dir.get{id}
      reads = tracks[id]
      if reads and changed-relevantly{obj, reads, writes}:
         return true
   false


changed-relevantly{match value, reads, writes} =
   ;; TODO: investigate why value might be null despite the presence
   ;; of reads and writes.
   {^methods.changed-relevantly => Function?} ->
      value[methods.changed-relevantly]{reads, writes}
   else ->
      Object.prototype[methods.changed-relevantly].call{value, reads, writes}
