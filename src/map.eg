
require:
   .util ->
      tuck, fork-identify
      ID, CACHE
      methods, fields
   .proxy ->
      setup-proxy
   .object-fill ->
      object-clobber-helper

provide:
   Map

class Map:

   constructor{} =
      @data = {=}

   get{key} =
      @data[key]

   set{String? key or Number? key, value} =
      @data[key] = value

   del{key} =
      delete @data[key]

   items{} =
      items{@data}

   [^methods.proxy]{tracks, patch, prevent-dirty-reads} =
      MapProxy{tracks, patch, prevent-dirty-reads}

   [^methods.iterate-properties]{} =
      Object.prototype[methods.iterate-properties].call{@data, @}

   [^methods.fork]{dir} =
      rval = Map{}
      {ID, CACHE} each field ->
         tuck{rval, field, @[field]}
      fork-identify{rval}
      dir.enter{rval, false}
      items{@} each {key, value} ->
         rval.data[key] = dir.acquire{value}
      rval

   [^methods.patch]{patch, dir} =
      Object.prototype[methods.patch].call{@data, patch, dir, @}

   [^methods.clobber]{new-map, dir} =
      if not Map? new-map:
         return dir.acquire{new-map}
      dir.exit{@}
      object-clobber-helper{
         @data, new-map.data, items
         {a, b} -> Object.has-own-property.call{a, b}
      } each
         #delete{k} ->
            delete @data[k]
         #put{k, v} ->
            @data[k] = dir.clobber{@data[k], v}
      tuck{@, ID, new-map[ID]}
      dir.enter{@}
      @

   [^methods.changed-relevantly]{reads, writes} =
      items{writes or {=}} each
         {name, _} when reads[name] ->
            return true
         when reads["@iter"] ->
            return true
      false



class MapProxy:

   constructor{obj, tracks, patch, prevent-dirty-reads = true} =
      setup-proxy{@, obj, tracks, patch, prevent-dirty-reads}

   get{key} =
      if @[fields.prevent-dirty-reads] and @[fields.obj-patch][key]:
         throw E.invalid_access with
            '''Cannot access key '{key}' after setting it.'''
      if @[fields.obj-tracks]: @[fields.obj-tracks][key] = true
      proxy{@[fields.obj][key]
            @[fields.tracks]
            @[fields.patch]
            @[fields.prevent-dirty-reads]}

   set{key, value} =
      if @[fields.obj-patch]:
         @[fields.obj-patch][key] = #update{deprox{new-value}}

   del{key} =
      if @[fields.obj-patch]:
         @[fields.obj-patch][key] = #delete{}

   items{} =
      if @[fields.obj-tracks]: @[fields.obj-tracks]["@iter"] = true
      @[fields.obj].items{} each {k, v} ->
         {k, proxy{v
                   @[fields.tracks]
                   @[fields.patch]
                   @[fields.prevent-dirty-reads]}}

