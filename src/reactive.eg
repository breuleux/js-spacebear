
require:
   "./index" ->
      deprox
      read-proxy, write-proxy ;;, patch, fork
      iterate-properties
      intersect, Directory
   "./util" ->
      tuck, identify, fork-identify
      ID, FORKID, VERSION, DIRECTORY, CACHE
   "./root" ->
      Root

provide:
   Reactive, reactive-function
   args-key
   System


arg-key{match x} =
   String? ->
      "S" + x
   null? or undefined? or Number? or Boolean? ->
      "P" + String{x}
   deprox! identify! fork-identify! x ->
      "O" + String{x[ID]} + ":" + String{x[FORKID]} ;; or ""}

args-key{args} =
   args.map{arg-key}.join{"\x00"}


get-replacement{match cached} =
   {=> get-replacement! replacement} ->
      replacement
   else ->
      cached


class CachedResult:

   constructor{@reactive, @args, @value, @deps, @version} =
      @children = {}
      @walk{@value}

   walk{identify! v} =
      iterate-properties{v} each {k, match obj, gen-patch} ->
         {^CACHE => cached} when cached ->
            @children.push with {k, v[ID], cached, gen-patch}
         else ->
            @walk{obj}
      undefined

   transform-patch-children{the-patch, new-patch, dir} =
      {children, @children} = {@children, {}}
      children each {k, vid, orig-cached and get-replacement! cached, gen-patch} ->
         if not cached.transform-patch{the-patch, new-patch, dir}:
            new-cached = cached.reactive.render{cached.args, true}
            cached.replacement = new-cached
            new-cached.transform-patch-children{the-patch, new-patch, dir}
            gen-patch{new-patch, new-cached.value}
            @children.push with {k, vid, new-cached, gen-patch}
         elif orig-cached !== cached:
            gen-patch{new-patch, cached.value}
            @children.push with {k, vid, cached, gen-patch}
         else:
            @children.push with {k, vid, cached, gen-patch}

   transform-patch{the-patch, new-patch, dir and {version => match}} =
      == @version or when not @version ->
         @transform-patch-children{the-patch, new-patch, dir}
         true
      == [@version + 1] ->
         dirty = @deps and intersect{@deps, the-patch, dir}
         if dirty:
            false
         else:
            @transform-patch-children{the-patch, new-patch, dir}
            @version += 1
            true
      else ->
         false


class Reactive:

   constructor{@renderfn} =
      @argmap = {=}

   render{args, force = false} =
      key = args-key{args}
      cached =
         match @argmap[key]:
            undefined? or [== true is force] ->
               @render-cache-object{args}
            cached ->
               cached
      @argmap[key] = cached
      cached

   render-cache-object{args} =
      deps = {=}
      pargs = args each deprox! arg -> read-proxy{arg, deps}
      {=> version = null} = deps[DIRECTORY]
      res = identify{@renderfn.apply{@, pargs}}
      cached = CachedResult{@, args, res, deps, version}
      tuck{res, CACHE, cached}
      cached


class System:

   constructor{@origin, @render, @options = {=}} =
      {clobber-patch => @clobber-patch = true
       action => @action = {x} -> x} = @options

      @bdir = Directory{}
      @basis = @bdir.acquire-copy{@origin}

      @vdir = Directory{clobber-patch = @clobber-patch}
      @value-root = CachedResult{null, null, r, null} where
         r = @vdir.acquire with Root{@render{@basis}, @action, true}

   get{} =
      @value-root.value.root

   update{the-patch} =
      @bdir.patch{the-patch}
      new-patch = {=}
      @value-root.transform-patch{the-patch, new-patch, @bdir}
      @vdir.patch{new-patch}

   transact{fn, Array! roots = {@basis}} =
      let patch = {=}
      proxies = roots each root -> write-proxy{root, patch}
      fn.apply{this, proxies}
      @update{patch}


reactive-function{render} =
   r = Reactive{render}
   rval{*args} =
      r.render{args}.value
   rval.orig = render
   rval
