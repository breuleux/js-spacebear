
require:
   "./proxy" ->
      Patch
      proxy, deprox, reprox
      read-proxy, write-proxy
   "./iter" ->
      iterate-properties
   "./relevant" ->
      intersect
   "./directory" ->
      Directory
   "./util" ->
      tuck, identify, fork-identify
      ID, FORKID, VERSION, DIRECTORY, CACHE
      fields
   "./root" ->
      Root

provide:
   Reactive, reactive-function
   args-key
   System, with-system, current-system



arg-key{match x} =
   String? ->
      "S" + x
   null? or undefined? or Number? or Boolean? ->
      "P" + String{x}
   deprox! identify! fork-identify! x ->
      "O" + String{x[ID]} + ":" + String{x[FORKID]} ;; or ""}

args-key{args} =
   args.map{arg-key}.join{"\x00"}


get-replacement{match cached} =
   {=> replacement} ->
      get-replacement{replacement}
   else ->
      cached


class CachedResult:

   constructor{@reactive, @self, @args, @value, @deps, @version} =
      @children = {}
      @walk{@value}

   walk{identify! v} =
      iterate-properties{v} each {k, match obj, gen-patch} ->
         {^CACHE => cached} when cached ->
            @children.push with {k, v[ID], cached, gen-patch}
         else ->
            @walk{obj}
      undefined

   transform-patch-children{the-patch, new-patch, dir} =
      {children, @children} = {@children, {}}
      children each {k, vid, orig-cached and get-replacement! cached, gen-patch} ->
         if not cached.transform-patch{the-patch, new-patch, dir}:
            new-cached = cached.reactive.render{cached.self, cached.args, true}
            cached.replacement = new-cached
            new-cached.transform-patch-children{the-patch, new-patch, dir}
            gen-patch{new-patch, new-cached.value}
            @children.push with {k, vid, new-cached, gen-patch}
         elif orig-cached !== cached:
            gen-patch{new-patch, cached.value}
            @children.push with {k, vid, cached, gen-patch}
         else:
            @children.push with {k, vid, cached, gen-patch}

   transform-patch{the-patch, new-patch, dir and {version => match}} =
      == @version or when not @version ->
         @transform-patch-children{the-patch, new-patch, dir}
         true
      == [@version + 1] ->
         dirty = @deps and intersect{@deps, the-patch, dir}
         if dirty:
            false
         else:
            @transform-patch-children{the-patch, new-patch, dir}
            @version += 1
            true
      else ->
         false


class Reactive:

   constructor{@renderfn} =
      @argmap = {=}

   render{the-self, args, force = false} =
      key = args-key{{the-self} ++ args}
      cached =
         match @argmap[key]:
            undefined? or [== true is force] ->
               @render-cache-object{the-self, args}
            cached ->
               cached
      @argmap[key] = cached
      cached

   render-cache-object{the-self, args} =
      deps = {=}
      ;; pargs = args each deprox! arg -> read-proxy{arg, deps}
      pargs = args each arg -> reprox{arg, deps, null}
      {=> version = null} = deps[DIRECTORY]
      res = identify{@renderfn.apply{the-self, pargs}}
      cached = CachedResult{@, reprox{the-self, deps, null}, args, res, deps, version}
      tuck{res, CACHE, cached}
      cached



system-stack = {}

with-system{sys, fn} =
   system-stack.unshift{sys}
   result = fn{}
   system-stack.shift{}
   result

current-system{} =
   system-stack[0]


class System:

   constructor{@origin, @render, @options = {=}} =
      identify{@}
      fork-identify{@}

      {clobber-patch => @clobber-patch = true
       action => @action = {x} -> x} = @options

      @patch-stack = {}
      @patch = Patch{}

      @bdir = Directory{}
      @basis = @bdir.acquire-copy{@origin}
      @basis.__SYSTEM = [@]
      @basis-proxy = proxy{@basis, null, @patch}

      @vdir = Directory{clobber-patch = @clobber-patch}

      rend = with-system{@, -> @render{@basis-proxy}}
      @value-root = CachedResult{null, null, null, r, null} where
         r = @vdir.acquire with
            Root{rend, @action, true}

   get{} =
      @value-root.value.root

   model{} =
      @basis-proxy

   push{} =
      @patch-stack.push with @patch.shift{}

   commit{} =
      @push{}
      {stack, @patch-stack} = {@patch-stack, {}}
      stack each patch ->
         @apply-patch{Patch{patch}}

   apply-patch{the-patch} =
      @bdir.patch{the-patch}
      new-patch = Patch{} ;; {=}
      with-system{@} with ->
         @value-root.transform-patch{the-patch, new-patch, @bdir}
      @vdir.patch{new-patch}

   transact{fn, Array! roots = {@basis}} =
      @push{}
      proxies = roots each root -> write-proxy{root, @patch}
      fn.apply{this, proxies}
      @commit{}


reactive-function{render} =
   r = Reactive{render}
   rval{*args} =
      system = current-system{}
      the-self = system.model{}
      r.render{the-self, args}.value
   rval.orig = render
   rval
