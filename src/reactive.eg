
require:
   "./index" ->
      deprox
      read-proxy, write-proxy, patch, fork
      iterate-properties
      intersect, directory
   "./util" ->
      tuck, identify, fork-identify, ID, FORKID, VERSION

provide:
   Reactive, reactive-function
   args-key
   System


arg-key{match x} =
   String? ->
      "S" + x
   null? or undefined? or Number? or Boolean? ->
      "P" + String{x}
   deprox! identify! fork-identify! x ->
      "O" + String{x[ID]} + ":" + String{x[FORKID]} ;; or ""}

args-key{args} =
   args.map{arg-key}.join{"\x00"}


class CachedResult:

   constructor{@value, @deps, @version
               @maybe-dirty-children = false
               @walk-later = false} =
      @children = {}
      if not @walk-later:
         @walk{@value}

   walk{v} =
      iterate-properties{v} each {k, match obj, gen-patch} ->
         {"::reactive" => r, "::arguments" => args, "::cached" => cached} ->
            @children.push with {k, v[ID], r, args, cached, gen-patch}
         else ->
            @walk{obj, patch}
      undefined

   transform-patch{the-patch, new-patch, dir} =
      if @walk-later:
         @walk{@value}
         @walk-later = false

      do-children{} =
         @children each data and {k, vid, r, args, cached, gen-patch} ->
            if not cached.transform-patch{the-patch, new-patch, dir}:
               new-value = r.render-with-patch{the-patch, new-patch, args, dir}
               gen-patch{new-patch, new-value}

      match the-patch[VERSION]:
         [== [@version + 1]] ->
            dirty = intersect{@deps, the-patch, dir}
            if dirty:
               false
            else:
               do-children{}
               @version += 1
               true
         [== @version] ->
            if @maybe-dirty-children:
               @maybe-dirty-children = false
               do-children{}
               true
            else:
               true
         else ->
            ;; At least one patch was skipped, so we have to recompile
            false


class Reactive:

   constructor{@renderfn-scratch, @renderfn-patch} =
      @argmap = {=}

   render-with-patch{the-patch, new-patch, args, dir} =
      key = args-key{args}
      cached =
         match @argmap[key]:
            undefined? ->
               @render-cache-object{args}
            cached ->
               cached
      @argmap[key] = cached
      if the-patch:
         if not cached.transform-patch{the-patch, new-patch, dir}:
            ;; if @renderfn-patch:

            ;;    ???
            ;;    deps = {=}
            ;;    if @renderfn-patch.call{@, pargs, the-patch, new-patch, deps}:
            ;;       pass
            ;;    else:
            ;;       return cached.value
            ;;    ???

            ;;    eeee

            delete @argmap[key]
            return @render-with-patch{the-patch, new-patch, args, dir}
      cached.value

   render-cache-object{args} =
      deps = {=}
      var version = null
      pargs = args each deprox! arg ->
         version or= arg[VERSION]
         read-proxy{arg, deps}
      res = identify{@renderfn-scratch.apply{@, pargs}}
      cache = CachedResult{res, deps, version, true}
      tuck{res, "::reactive", [@]}
      tuck{res, "::arguments", args}
      tuck{res, "::cached", cache}
      cache

   render{args} =
      @render-cache-object{args}.value


class System:

   constructor{@origin, @render} =
      @basis = fork{@origin}
      @bdir = directory{@basis}

      @value = @render{@basis}
      @vdir = directory{@value}

      @version = 1

   update{the-patch} =
      patch{@basis, the-patch, @bdir}
      new-patch = {=}
      tuck{new-patch, VERSION, @version}
      ;; print the-patch
      ;; print @value["::cached"].deps
      @value = @value["::reactive"].render-with-patch{
         the-patch, new-patch, {@basis}, @bdir
      }
      directory{@value, @vdir}
      patch{@value, new-patch, @vdir}

   transact{fn, Array! roots = @basis} =
      let patch = Object.create{null}
      proxies = roots each root -> write-proxy{root, patch}
      fn.apply{this, proxies}
      @version += 1
      tuck{patch, VERSION, @version}
      @update{patch}


reactive-function{render} =
   r = Reactive{render}
   rval{*args} =
      r.render-with-patch{null, null, args, null}
   rval.orig = render
   rval

;; reactive-each{render-item} =
;;    r = Reactive{render}
;;    rval{*args} =
;;       r.render-with-patch{null, null, args, null}
;;    rval.orig = render
;;    rval
