
require:
   "./index" ->
      deprox
      read-proxy, write-proxy, patch, fork
      iterate-properties
      intersect, directory
   "./util" ->
      tuck, identify, ID, FORKID, VERSION

provide:
   Reactive, reactive-function
   args-key
   System


arg-key{match x} =
   String? ->
      "S" + x
   null? or undefined? or Number? or Boolean? ->
      "P" + String{x}
   deprox! identify! x ->
      "O" + String{x[ID]} + ":" + String{x[FORKID] or ""}

args-key{args} =
   args.map{arg-key}.join{"\x00"}


class CachedResult:

   constructor{@value, @deps, @version, @maybe-dirty-children = false} =
      @children = {}
      @walk{@value}

   walk{v} =
      iterate-properties{v} each {k, match obj, make-patch} ->
         {"::reactive" => r, "::arguments" => args, "::cached" => cached} ->
            @children.push with {k, v[ID], r, args, cached, make-patch}
         else ->
            @walk{obj, patch}
      undefined

   transform-patch{the-patch, new-patch, dir} =
      do-children{} =
         @children each data and {k, vid, r, args, cached, make-patch} ->
            if not cached.transform-patch{the-patch, new-patch, dir}:
               new-value = r.render-with-patch{the-patch, new-patch, args, dir}
               new-patch[vid] or= {=}
               new-patch[vid][k] = make-patch{new-value}

      match the-patch[VERSION]:
         [== [@version + 1]] ->
            dirty = intersect{@deps, the-patch, dir}
            if dirty:
               false
            else:
               do-children{}
               @version += 1
               true
         [== @version] ->
            if @maybe-dirty-children:
               @maybe-dirty-children = false
               do-children{}
               true
            else:
               true
         else ->
            ;; At least one patch was skipped, so we have to recompile
            false


class Reactive:

   constructor{@renderfn} =
      @argmap = {=}

   render-with-patch{the-patch, new-patch, args, dir} =
      key = args-key{args}
      cached =
         match @argmap[key]:
            undefined? ->
               @render-cache-object{args}
            cached ->
               cached
      @argmap[key] = cached
      if the-patch:
         if not cached.transform-patch{the-patch, new-patch, dir}:
            delete @argmap[key]
            return @render-with-patch{the-patch, new-patch, args, dir}
      cached.value

   render-cache-object{args} =
      deps = {=}
      var version = null
      pargs = args each deprox! arg ->
         version or= arg[VERSION]
         read-proxy{arg, deps}
      res = identify{@renderfn.apply{@, pargs}}
      cache = CachedResult{res, deps, version, true}
      tuck{res, "::reactive", [@]}
      tuck{res, "::arguments", args}
      tuck{res, "::cached", cache}
      cache

   render{args} =
      @render-cache-object{args}.value


class System:

   constructor{@origin, @render} =
      @basis = fork{@origin}
      @bdir = directory{@basis}

      @value = @render{@basis}
      @vdir = directory{@value}

      @version = 1

   update{the-patch} =
      patch{@basis, the-patch, @bdir}
      new-patch = {=}
      tuck{new-patch, VERSION, @version}
      @value = @value["::reactive"].render-with-patch{
         the-patch, new-patch, {@basis}, @bdir
      }
      directory{@value, @vdir}
      patch{@value, new-patch, @vdir}

   transact{fn, Array! roots = @basis} =
      let patch = Object.create{null}
      proxies = roots each root -> write-proxy{root, patch}
      fn.apply{this, proxies}
      @version += 1
      tuck{patch, VERSION, @version}
      @update{patch}


reactive-function{render} =
   r = Reactive{render}
   rval{*args} =
      r.render-with-patch{null, null, args, null}
   rval.orig = render
   rval
