
require:
   "./util" ->
      identify, fork-identify, tuck
      next-id, ID, FORKID, VERSION, DIRECTORY, CACHE
      methods
      longest-run
   "./proxy" ->
      deprox
   "./iter" ->
      iterate-properties

provide:
   object-clobber-helper


Object.prototype[methods.fork]{dir} =
   obj = this
   rval = Object.create{Object.get-prototype-of{obj}}
   {ID, CACHE} each field ->
      tuck{rval, field, obj[field]}
   fork-identify{rval}
   dir.enter{rval, false}
   items{obj} each {key, value} ->
      rval[key] = dir.acquire{value}
   rval


Object.prototype[methods.patch]{p, dir, wrapper = this} =
   obj = this
   identify{wrapper}
   match p.get-for{wrapper}:
      undefined? -> pass
      items! [each {field, match}] ->
         #update{value} ->
            obj[field] = dir.replace{obj[field], value}
   obj


object-clobber-helper{obj, new-obj, items, owns} =
   operations = {}
   items{obj} each
      {k, v} when not owns{new-obj, k} ->
         operations.push with #delete{k}
   items{new-obj} each {k, match v} ->
      do: v0 = obj[k]
      === v0 or when v0 and v0[ID] and v and v[ID] == v0[ID] ->
         pass
      else ->
         operations.push with #put{k, v}
   operations

Object.prototype[methods.clobber]{new-obj, dir} =
   obj = this

   if Object.get-prototype-of{obj} !== Object.get-prototype-of{new-obj}:
      return dir.acquire{new-obj}

   dir.exit{obj}

   object-clobber-helper{
      obj, new-obj, items
      {a, b} -> Object.has-own-property.call{a, b}
   } each
      #delete{k} ->
         delete obj[k]
      #put{k, v} ->
         obj[k] = dir.clobber{obj[k], v}

   tuck{obj, ID, new-obj[ID]}
   dir.enter{obj}

   obj
