
require:
   .object-fill
   .array-fill
   .misc-fill
   .util ->
      tuck, identify, next-id
      ID, FORKID, VERSION, SOURCE, DIRECTORY, CACHE
      methods, fields
   "./struct" ->
      make-struct, struct
   "./proxy" ->
      Patch, Tracks
      proxy, deprox, reprox
      read-proxy, write-proxy
   .iter ->
      iterate-properties
   .directory ->
      Directory
   .relevant ->
      intersect, changed-relevantly
   .root ->
      Root
   .vdom ->
      VNode, ENode as EVNode
   "./reactive" ->
      System, reactive-function, reactive-function2
      current-system

      State, DependentState, transact-all
   .map ->
      Map
   .render ->
      RenderState

provide:
   identify, tuck
   ID, FORKID, VERSION, SOURCE, DIRECTORY, CACHE
   methods, fields
   make-struct, struct
   Patch, Tracks
   proxy, deprox, reprox
   read-proxy, write-proxy
   Directory
   iterate-properties
   changed-relevantly
   intersect
   Root
   VNode, EVNode as ENode
   System, reactive-function, reactive-function2
   State, DependentState
   transact-all
   current-system
   Map
   RenderState

   percent as [%]
   reactive
   transact


macro{EVNode} percent{#data{x, y}} =
   let {=> EVNode} = @deps
   `[^x % ^y] where ENode = [^EVNode]`


;; macro{reactive-function} reactive{expr} =
;;    let {"reactive-function" => rfn} = @deps
;;    {system, it, self} = @mark{`system`, `@`, `self`}
;;    @multimacro with {
;;       project{`^args -> ^body`} =
;;          ```
;;          [^rfn] with
;;             ^args ->
;;                let ^system = this.__SYSTEM
;;                let ^it and ^self = this
;;                ^body
;;          ```
;;    }

;; macro{} transact{#data{body}} =
;;    system = @mark{`system`}
;;    ```
;;    [^system].transact with {_} -> ^body
;;    ```


macro{reactive-function2} reactive{expr} =
   let {"reactive-function2" => rfn} = @deps
   {system, it, self} = @mark{`system`, `@`, `self`}
   @multimacro with {
      project{match expr} =
         `_lambda{^args, ^pre, ^body, ^post, ^gen}` ->
            ```
            [^rfn]{_lambda{^args, ^pre, [let ^it and ^self = this, ^body], ^post, ^gen}}
            ```
         `^args -> ^body` ->
            ```
            [^rfn] with
               ^args ->
                  let ^it and ^self = this
                  ^body
            ```
         else ->
            print expr
            throw E.syntax.invalid-reactive{"invalid", node = expr}
   }

macro{transact-all} transact{#data{body}} =
   let {"transact-all" => tra} = @deps
   `[^tra] with {_} -> ^body`
