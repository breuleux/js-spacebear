
require:
   "./fork" -> fork
   "./patch" ->
      patch
      array-patch
      array-iterate-properties
   "./proxy" ->
      proxy, deprox
   "./util" ->
      tuck, identify, next-id
      ID, FORKID, VERSION, SOURCE
   util -> inspect

provide:
   SBArray, A


class SBArray:

   constructor{entries} =
      identify{@}
      tuck{@, VERSION, 1}
      @_a = entries each x -> x

   .get{i} =
      if i < 0 or i >= @_a.length:
         throw E.outofbounds{'''Index {i} is out of range for {@}'''}
      @_a[i]

   slice{i, j} =
      @_a.slice{i, j}[Symbol.iterator]{}

   for-each{fn} =
      this each x -> fn{x}
      undefined

   map{fn} =
      this each x -> fn{x}

   .set{i, new-value} =
      this._splice{i, 1, {new-value}, false}

   pop{n = 1} =
      this._splice{@_a.length - n, n, {}, false}
   push{*values} =
      this._splice{@_a.length, 0, values, .append}

   shift{n = 1} =
      this._splice{0, n, {}, false}
   unshift{*values} =
      this._splice{0, 0, values, .prepend}

   .splice{i, n, *values} =
      this._splice{i, n, values, false}

   replace{new-array} =
      this._splice{0, @_a.length, new-array, false}

   _splice{i, n, values, _} =
      @_a.splice{i, n, *values}

   to-string{} =
      '\{{@_a.join{", "}}\}'

   inspect{depth} =
      inspect{@_a, depth}


   proxy{tracks, patch, prevent-dirty-reads} =
      sbarray-proxy{this, tracks, patch, prevent-dirty-reads}

   fork{dir} =
      rval = Object.create{SBArray.prototype}
      dir[this[ID]] = rval
      tuck{rval, ID, this[ID]}
      tuck{rval, FORKID, next-id{}}
      tuck{rval, VERSION, 1}
      rval._a = @_a each x -> fork{x, dir}
      rval

   patch{p} =
      array-patch{@_a, p, @}

   iterate-properties{} =
      array-iterate-properties{@_a, @}

   changed-relevantly{reads, writes} =
      match writes["@splice"]:
         undefined? ->
            false
         splices ->
            var mask = 3
            taints = splices each
               undefined? -> 3 &+ mask
               {1, {_}} -> 1 &+ mask
               else -> [mask = 0; 0]
            items{reads} each
               {"@iter", {i, j, stick}} ->
                  if stick and taints[taints.length - 1] != 3:
                     return true
                  taints.slice{i, j} each
                     3 -> pass
                     else -> return true
               {n, v} when v ->
                  if taints[n] != 3:
                     return true
      false


SBArray.prototype[Symbol.iterator]{} =
   this._a[Symbol.iterator]{}

Object.define-property{SBArray.prototype, .length} with {
   .get{} = this._a.length
}



sbarray-proxy{obj, tracks, patch, var prevent-dirty-reads = true} =
   a = obj._a

   id = obj[ID]
   obj-tracks = tracks and id and [tracks[id] or= {=}]
   if obj-tracks:
      tuck{obj-tracks, SOURCE, obj}

   obj-patch = patch and id and [patch[id] or= {=}]
   if obj-patch:
      tuck{obj-patch, SOURCE, obj}
   else:
      prevent-dirty-reads = false

   update-iter{match, i, j, stick-to-end = false} =
      undefined? ->
         {i, j, stick-to-end}
      {i2, j2} ->
         {Math.min{i, i2}, Math.max{j, j2}, stick-to-end}
      else ->
         {i, j, stick-to-end}

   prox = Object.create{Object.create{SBArray.prototype} &: [getters & setters]} where

      getters = {
         .get{i} =
            if prevent-dirty-reads and obj-patch[i]:
               throw E.invalid_access with
                  '''Cannot access index '{i}' after setting it.'''
            if obj-tracks: obj-tracks[i] = true
            proxy{obj.get{i}, tracks, patch, prevent-dirty-reads}
         slice{i = 0, var j = null} =
            stick = if{j === null, [j = a.length; true], false}
            if obj-tracks:
               obj-tracks["@iter"] = update-iter{obj-tracks["@iter"], i, j, stick}
            obj.slice{i, j} each* x ->
               proxy{x, tracks, patch, prevent-dirty-reads}
         ^Symbol.iterator = {} ->
            proxies = obj each x -> proxy{x, tracks, patch, prevent-dirty-reads}
            if obj-tracks: obj-tracks["@iter"] = {0, a.length, true}
            proxies[Symbol.iterator]{}
      }

      setters =
         if obj-patch: {

            ._splice{i, n, values, pos = false} =
               emsg = 'Inconsistent splicing (this may happen if you modify'
                  \ + ' the array more than once at the same place)'
               d = [obj-patch["@splice"] or= Array{a.length + 1}]
               match d[i]:
                  === true ->
                     throw E.splice{emsg}
                  undefined? ->
                     d[i] = {n, values}
                  {n2, previous-values} when n == 0 or n2 == 0 ->
                     d[i] = {Math.max{n, n2}, new-values} where new-values =
                        match pos:
                           .prepend -> values ++ previous-values
                           .append -> previous-values ++ values
                           else -> throw E.splice{emsg}
                  else ->
                     throw E.splice{emsg}
               1..[n - 1] each j ->
                  match d[i + j]:
                     undefined? ->
                        d[i + j] = true
                     else ->
                        throw E.splice{emsg}
         }

         else: {
            _splice{} =
               throw E.immutable{'''Cannot modify {obj}'''}
         }

   Object.define-property{prox, .length} with {
      .get{} =
         if prevent-dirty-reads and obj-patch[.length]:
            throw E.invalid_access with
               '''Array length has changed.'''
         if obj-tracks: obj-tracks[.length] = true
         proxy{obj[.length], tracks, patch, prevent-dirty-reads}
   }

   tuck{prox, ._a, a}

   prox


A{*entries} = SBArray{entries}

