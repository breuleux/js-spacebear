
require:
   "./util" ->
      tuck, identify, next-id, ID, FORKID, VERSION, SOURCE
   "./proxy" ->
      deprox

provide:
   directory
   patch, patch-shallow
   iterate-properties


directory{match v, dir = {=}} =

   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      dir

   else ->
      id = v[ID]
      if not id: return dir
      match dir[v[ID]]:
         undefined? ->
            dir[v[ID]] = deprox{v}
            iterate-properties{v} each {k, v2, replace} ->
               directory{v2, dir}
         obj ->
            dir
      dir


patch-shallow{match value, p} =

   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      pass

   Object.is-frozen? ->
      throw E.spacebear.patch with
         'Cannot patch frozen objects.'

   {patch => Function?} ->
      deprox{value}.patch{p}

   Array? ->
      throw E.spacebear.patch with
         'Cannot patch arrays. Wrap with spacebear.Array.'

   deprox! obj ->
      object-patch{deprox{obj}, p}
      undefined


patch{value, p, dir = directory{value}} =
   items{p} each {id, obj-patch} ->
      obj = dir[id]
      patch-shallow{obj, p}
      ;; Refresh directory
      iterate-properties{obj} each {k, v, replace} ->
         directory{v, dir}


object-patch{identify! obj, p} =
   if obj[VERSION] === p[VERSION]:
      return obj
   tuck{obj, VERSION, p[VERSION]}

   match p[obj[ID]]:
      undefined? -> pass
      items! [each {field, match}] ->
         #update{value} ->
            obj[field] = value

   obj



iterate-properties{match obj} =

   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      {}

   Object.is-frozen? ->
      throw E.spacebear.patch with
         'Cannot iterate frozen objects.'

   {iterate-properties => Function?} ->
      deprox{obj}.iterate-properties{}

   Array? ->
      throw E.spacebear.iterate with
         'Cannot iterate arrays. Wrap with spacebear.Array.'

   else ->
      object-iterate-properties{deprox{obj}}


object-iterate-properties{obj} =
   items{obj} each {k, v} ->
      {k, v, replace} where
         replace{new-v} = obj[k] = new-v


