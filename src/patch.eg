
require:
   "./util" ->
      tuck, identify, next-id, ID, FORKID, VERSION, SOURCE
   "./proxy" ->
      deprox

provide:
   patch, patch-shallow
   iterate-properties



patch-shallow{match value, p} =

   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      pass

   Object.is-frozen? ->
      throw E.spacebear.patch with
         'Cannot patch frozen objects.'

   {patch => Function?} ->
      deprox{value}.patch{p}

   Array? ->
      throw E.spacebear.patch with
         'Cannot patch arrays. Wrap with spacebear.Array.'

   deprox! obj ->
      object-patch{deprox{obj}, p}
      undefined


patch{value, p} =
   patch-shallow{value, p}
   iterate-properties{value} each {k, v, replace} ->
      patch{v, p}



object-patch{identify! obj, p} =
   if obj[VERSION] === p[VERSION]:
      return obj
   tuck{obj, VERSION, p[VERSION]}

   match p[obj[ID]]:
      undefined? -> pass
      items! [each {field, match}] ->
         #update{value} ->
            obj[field] = value

   ;; items{obj} each {_, v} ->
   ;;    patch{v, p}

   obj



iterate-properties{match obj} =

   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      {}

   Object.is-frozen? ->
      throw E.spacebear.patch with
         'Cannot iterate frozen objects.'

   {iterate-properties => Function?} ->
      deprox{obj}.iterate-properties{}

   Array? ->
      throw E.spacebear.iterate with
         'Cannot iterate arrays. Wrap with spacebear.Array.'

   else ->
      object-iterate-properties{deprox{obj}}


object-iterate-properties{obj} =
   items{obj} each {k, v} ->
      {k, v, replace} where
         replace{new-v} = obj[k] = new-v


