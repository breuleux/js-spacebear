
require:
   "./util" ->
      tuck, identify, next-id, ID, FORKID, VERSION, SOURCE
   "./proxy" ->
      deprox
   "./clobber" ->
      clobber
   "./iter" ->
      iterate-properties
   "./directory" ->
      directory

provide:
   patch, patch-shallow
   object-patch, array-patch



patch-shallow{match value, p, clobber = false} =

   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      pass

   Object.is-frozen? ->
      throw E.spacebear.patch with
         'Cannot patch frozen objects.'

   {patch => Function?} ->
      deprox{value}.patch{p, clobber}

   Array? arr ->
      array-patch{arr, p, arr, clobber}

   deprox! obj ->
      object-patch{obj, p, obj, clobber}
      undefined


patch{value, p, dir = directory{value}, clobber = false} =
   items{p} each {id, obj-patch} ->
      dir.get-all{id} each obj ->
         patch-shallow{obj, p}
         ;; Refresh directory
         iterate-properties{obj} each {k, v, replace} ->
            directory{v, dir}


object-patch{obj, p, wrapper = obj, _clobber = false} =

   identify{wrapper}
   if wrapper[VERSION] === p[VERSION]:
      return obj
   tuck{wrapper, VERSION, p[VERSION]}

   match p[wrapper[ID]]:
      undefined? -> pass
      items! [each {field, match}] ->
         #update{value} ->
            obj[field] =
               if _clobber:
                  clobber{obj[field], value}
               else:
                  value

   obj

array-patch{arr, p, wrapper = arr, _clobber = false} =
   ;; TODO: _clobber

   identify{wrapper}
   if wrapper[VERSION] === p[VERSION]:
      return arr
   tuck{wrapper, VERSION, p[VERSION]}

   splices = p??[wrapper[ID]]??["@splice"]
   if not splices:
      return
   enumerate{splices}.reverse{} each {i, match} ->
      {n, repl} ->
         arr.splice{i, n, *repl}
      else ->
         pass
   undefined

