
require:
   "./util" ->
      identify, fork-identify, tuck
      next-id, ID, FORKID, VERSION, DIRECTORY, CACHE
      methods
      longest-run
   "./proxy" ->
      deprox
   "./iter" ->
      iterate-properties

provide:
   array-clobber-helper


;;;;;;;;;;
;; FORK ;;
;;;;;;;;;;

Array.prototype[methods.fork]{dir} =
   arr = this
   rval = {}
   {ID, CACHE} each field ->
      tuck{rval, field, arr[field]}
   fork-identify{rval}
   dir.enter{rval, false}
   arr each x ->
      rval.push{dir.acquire{x}}
   rval


;;;;;;;;;;;
;; PATCH ;;
;;;;;;;;;;;

Array.prototype[methods.patch]{p, dir, wrapper = this} =
   arr = this
   identify{wrapper}
   splices = p.get-for{wrapper}??["@splice"]
   if not splices:
      return
   enumerate{splices}.reverse{} each {i, match} ->
      {n, repl} ->
         previous = arr.splice{i, n}
         var acq =
            zip{repl.slice{0, previous.length}, previous} each {newv, oldv} ->
               dir.replace{oldv, deprox{newv}}
         acq ++= repl.slice{previous.length} each newv ->
            dir.acquire{deprox{newv}}
         previous.slice{repl.length} each oldv ->
            dir.exit{oldv}
         arr.splice{i, 0, *acq}
      else ->
         pass
   undefined


;;;;;;;;;;;;;
;; CLOBBER ;;
;;;;;;;;;;;;;

array-clobber-helper{arr, new-arr, duplicate = true} =

   ;; 1. For each element of the new array, find the index of the
   ;; corresponding element in the old array.

   ;; 2. Find the longest filtering of the array of indices such
   ;; that the indices are in order.

   ;; 3. Splice the data around these fixed points, which should
   ;; amount to the minimal splicing that transforms the array

   idpos = {=}
   enumerate{arr} each {i, match x} ->
      {^ID => Number? id} -> idpos[id] = {i, x}
      else -> continue

   indices = enumerate{new-arr} each {i, match x} ->
      {^ID => Number? id} when idpos[id] -> {i, idpos[id][0]}
      else -> continue

   run = longest-run{indices, cmp, {-1, -1}} where
      cmp{{_, p1}, {_, p2}} = p1 < p2

   newids = {=}
   new-arr each x and {^ID => Number? id} when true ->
      newids[id] = true
   disposable = {=}
   arr each x and {^ID => Number? id} when not newids[id] ->
      disposable[id] = true

   if duplicate:
      run each {new-i, old-i} ->
         ;; These will be automatically preserved
         delete idpos[arr[old-i][ID]]

   run.push with {new-arr.length, arr.length}

   var old-current = 0
   var new-current = 0

   operations = {}
   run each {new-i, old-i} ->
      var n = old-i - old-current
      fresh = new-arr.slice{new-current, new-i}

      ;; Clobber what we can, shifting the splice
      while n > 0 and old-current < old-i and fresh.length > 0:
         match arr[old-current]:
            x and {^ID => Number? id} when disposable[id] ->
               operations.push with #clobber{new-current, fresh.shift{}}
               old-current += 1
               new-current += 1
               n -= 1
            else ->
               break

      ;; But now we have to replace a slice
      inserts = fresh each
         entry and {_, orig} is idpos[entry[ID] or -1] when duplicate ->
            ;; We can recover this entry; however dir.duplicate prevents
            ;; us from having the same reference more than once in the
            ;; tree, so we remove it from idpos so we can't reuse it.
            delete idpos[entry[ID]]
            #keep{orig}
         entry ->
            #acquire{entry}

      operations.push with
         #splice{new-current, n, inserts}
      old-current = old-i + 1
      new-current = new-i + 1

   operations


Array.prototype[methods.clobber]{new-arr, dir} =

   arr = this

   if not Array? new-arr:
      return dir.acquire{new-arr}

   dir.exit{arr}

   array-clobber-helper{arr, new-arr, dir.duplicate} each
      #clobber{i, value} ->
         arr[i] = dir.clobber{arr[i], value}
      #splice{var start, var n, inserts} ->
         arr.splice{start, n, *acquired} where
            acquired = inserts each
               #keep{x} -> x
               #acquire{x} -> dir.acquire{x}

   tuck{arr, ID, new-arr[ID]}
   dir.enter{arr}
   arr


;;;;;;;;;;;;;;;;;;;;;;;;
;; ITERATE-PROPERTIES ;;
;;;;;;;;;;;;;;;;;;;;;;;;

Array.prototype[methods.iterate-properties]{wrapper = this} =
   arr = this
   id = wrapper[ID]
   enumerate{arr} each {i, v} ->
      {i, v, gen-patch} where
         gen-patch{patch, new-v} =
            ap = patch.get{id}
            ap["@splice"] or= Array{arr.length + 1}
            ap["@splice"][i] = {1, {new-v}}


;;;;;;;;;;;;;;;;;;;;;;;;
;; CHANGED-RELEVANTLY ;;
;;;;;;;;;;;;;;;;;;;;;;;;

Array.prototype[methods.changed-relevantly]{reads, writes} =
   match writes["@splice"]:
      undefined? ->
         false
      splices ->
         var mask = 3
         taints = splices each
            undefined? -> 3 &+ mask
            {1, {_}} -> 1 &+ mask
            else -> [mask = 0; 0]
         items{reads} each
            {"@iter", {i, j, stick}} ->
               if stick and taints[taints.length - 1] != 3:
                  return true
               taints.slice{i, j} each
                  3 -> pass
                  else -> return true
            {n, v} when v ->
               if taints[n] != 3:
                  return true
   false

